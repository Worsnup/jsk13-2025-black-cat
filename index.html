<!-- TODO 2. Add collisions with static bodies -->
<!-- TODO 3. Need to optimize so it runs 1000 node rope easily -->

<script>
 document.addEventListener('DOMContentLoaded', () => {
  // ===== Canvas bootstrap =====
  const $ = document, W = window, B = $.body, C = $.createElement('canvas'), X = C.getContext('2d');
  (document.getElementById('content') || B).innerHTML = '';
  Object.assign(B.style, {margin: 0, overflow: 'hidden'});
  Object.assign(C.style, {display: 'block', touchAction: 'none'});
  B.appendChild(C);

  // ===== Math helpers =====
  const {min, max, hypot, sqrt, sin, cos, PI, random} = Math;
  const clamp = (v, a, b) => max(a, min(b, v));

  // ===== World / DPI =====
  const DPR = min(2, W.devicePixelRatio || 1);
  function fitCanvasToWindow() {
   const w = W.innerWidth || $.documentElement.clientWidth;
   const h = W.innerHeight || $.documentElement.clientHeight;
   Object.assign(C.style, {width: w + 'px', height: h + 'px'});
   C.width = (w * DPR) | 0; C.height = (h * DPR) | 0;
   X.setTransform(DPR, 0, 0, DPR, 0, 0);
   // renderer handles its own scaling; simulator works only in meters.
  }
  W.addEventListener('resize', fitCanvasToWindow);

  // ========================================
  // CONFIG: TUNABLE
  // ========================================
  const TUNE = {
   SIM: {
    DT_S:                1/60,
    SUBSTEPS:            1,
    ITERS:               18,
    GRAVITY_MPS2:        [0, 9.81],
    DRAG:                0.01,
    BOUNDS_M:            [0, 0, 8, 6],
    COLLIDE_CIRCLES:     true,
    CONTACT_COMPLIANCE_M_PER_N: 0
   },
   RENDER: {
    BG:                  '#0b0d12',
    LINK_STROKE:         '#d43375',
    LINK_WIDTH_PX:       3,
    PARTICLE_FILL:       '#ffd166',
    PARTICLE_STROKE:     '#222',
    PARTICLE_STROKE_W:   1,
    PIN_FILL:            '#ff6b6b',
    SHOW_BOUNDS:         false,
    PIXELS_PER_METER:    130
   },
   DEMO: {
    ROPE_COUNT:          200,
    ROPE_START_M:        {x: 4, y: 0.8},
    ROPE_SEG_LEN_M:      0.10,
    ROPE_NODE_MASS_KG:   0.01,
    ROPE_NODE_RADIUS_M:  0.025,
    ROPE_STIFFNESS_N_PER_M: 1e8,

    BALL_POS_M:          {x: 6, y: 4.3},
    BALL_RADIUS_M:       0.30,
    BALL_MASS_KG:        2,

    MAX_FRAME_DT_S:      1/30,
    CLICK_POKE_N_PER_M:  300
   }
  };

  // =========================
  // XPBD core
  // =========================
  const INTERNAL = { EPS_M: 1e-9, LAMBDA_DECAY: 1.0 };
  function XPBD(opt = {}) {
   const Wd = {
    dt: opt.dt ?? TUNE.SIM.DT_S,
    substeps: opt.substeps ?? TUNE.SIM.SUBSTEPS,
    iters: opt.iters ?? TUNE.SIM.ITERS,
    g: opt.g ?? TUNE.SIM.GRAVITY_MPS2.slice(),
    drag: opt.drag ?? TUNE.SIM.DRAG,
    bounds: opt.bounds ?? (TUNE.SIM.BOUNDS_M && TUNE.SIM.BOUNDS_M.slice()),
    contactCompliance: opt.contactCompliance ?? TUNE.SIM.CONTACT_COMPLIANCE_M_PER_N,
    collide: opt.collide ?? TUNE.SIM.COLLIDE_CIRCLES,
    P: [],  // particles
    C: [],  // distance constraints
    T: []   // tethers (unused here but supported)
   };
   function add(x_m, y_m, mass_kg = 1, radius_m = 0, col_mask=7, active=true) {
    const w = mass_kg > 0 ? 1 / mass_kg : 0;
    const p = { x: x_m, y: y_m, px: x_m, py: y_m, vx: 0, vy: 0, w, r: radius_m, col_mask, active };
    Wd.P.push(p); return p;
   }
   function setStatic(p, yes = true) { p.w = yes ? 0 : (p.w || 1); }
   function link(a, b, rest_m = null, compliance_m_per_N = 0) {
    if (rest_m == null) { const dx = b.x - a.x, dy = b.y - a.y; rest_m = Math.hypot(dx, dy); }
    const c = { a, b, rest: rest_m, comp: compliance_m_per_N, lam: 0 };
    Wd.C.push(c); return c;
   }
   function addForce(p, Fx_N, Fy_N) {
    if (!p.w) return p;
    p.vx += (Fx_N * p.w) * Wd.dt;
    p.vy += (Fy_N * p.w) * Wd.dt;
    return p;
   }
   function step(dt = Wd.dt) {
    const P = Wd.P, Cn = Wd.C, Th = Wd.T, g = Wd.g, drag = Wd.drag, sub = Wd.substeps, it = Wd.iters;
    const hasBounds = !!Wd.bounds, B = Wd.bounds;
    const doCollide = !!Wd.collide, cComp = Wd.contactCompliance;

    const sdt = dt / sub;
    const invDrag = 1 / (1 + drag);
    const alphaScale = sdt * sdt;

    for (let s = 0; s < sub; s++) {
     // integrate
     for (let i = 0; i < P.length; i++) {
      if (!P[i].active) continue;
      const p = P[i];
      p.px = p.x; p.py = p.y;
      if (!p.w) continue;
      p.vx += g[0] * sdt; p.vy += g[1] * sdt;
      p.vx *= invDrag;    p.vy *= invDrag;
      p.x += p.vx * sdt;  p.y += p.vy * sdt;
     }

     // solver iterations
     for (let k = 0; k < it; k++) {
      // Teathers constraints (equality)
      for (let i = 0; i < Th.length; i++) {
       const t = Th[i], a = t.a, b = t.b;
       let dx = a.x - b.x, dy = a.y - b.y;
       let d = Math.hypot(dx, dy); if (d < INTERNAL.EPS_M) d = INTERNAL.EPS_M;
       const Cval = t.max - d;
       if (Cval >= 0) { t.lam = 0; continue; }
       const nx = dx / d, ny = dy / d;
       const wsum = a.w + b.w; if (wsum === 0) continue;
       const alpha = (t.comp || 0) / alphaScale;
       const oldLam = Math.max(0, t.lam) * INTERNAL.LAMBDA_DECAY;
       let dlam = (-Cval - alpha * oldLam) / (wsum + alpha);
       let newLam = oldLam + dlam;
       if (newLam < 0) { dlam = -oldLam; newLam = 0; }
       const px = dlam * nx, py = dlam * ny;
       if (a.w) { a.x -= px * a.w; a.y -= py * a.w; }
       if (b.w) { b.x += px * b.w; b.y += py * b.w; }
       t.lam = newLam;
      }

      // Distance constraints (equality)
      for (let i = 0; i < Cn.length; i++) {
       const c = Cn[i], a = c.a, b = c.b;
       let dx = b.x - a.x, dy = b.y - a.y;
       let d = Math.hypot(dx, dy);
       if (d < INTERNAL.EPS_M) continue;
       const nx = dx / d, ny = dy / d;
       const Cval = d - c.rest;
       const wsum = a.w + b.w;
       if (wsum === 0) { c.lam = 0; continue; }
       const alpha = (c.comp || 0) / alphaScale;
       const oldLam = c.lam * INTERNAL.LAMBDA_DECAY;
       const dlam = (-Cval - alpha * oldLam) / (wsum + alpha);
       c.lam = oldLam + dlam;
       const px = dlam * nx, py = dlam * ny;
       if (a.w) { a.x -= px * a.w; a.y -= py * a.w; }
       if (b.w) { b.x += px * b.w; b.y += py * b.w; }
      }

      // bounds
      if (hasBounds) {
       const [minx, miny, maxx, maxy] = B;
       for (let i = 0; i < P.length; i++) {
        if (!P[i].active) continue;
        const p = P[i], r = p.r || 0;
        if (p.x < minx + r) p.x = minx + r;
        if (p.x > maxx - r) p.x = maxx - r;
        if (p.y < miny + r) p.y = miny + r;
        if (p.y > maxy - r) p.y = maxy - r;
       }
      }

      // circle–circle contacts
      if (doCollide) {
       const alphaC = (cComp || 0) / alphaScale;
       for (let i = 0; i < P.length; i++) {
        const a = P[i]; if (!a.r || !a.active) continue;
        for (let j = i + 1; j < P.length; j++) {
         const b = P[j]; if (!b.r || !b.active) continue;
         if ((a.col_mask & b.col_mask) === 0) continue;
         let dx = b.x - a.x, dy = b.y - a.y;
         let d = Math.hypot(dx, dy); if (d < INTERNAL.EPS_M) d = INTERNAL.EPS_M;
         const rs = (a.r || 0) + (b.r || 0);
         const Cval = d - rs; if (Cval >= 0) continue;
         const nx = dx / d, ny = dy / d;
         const wsum = a.w + b.w; if (wsum === 0) continue;
         const dlam = (-Cval) / (wsum + alphaC);
         const px = dlam * nx, py = dlam * ny;
         if (a.w) { a.x -= px * a.w; a.y -= py * a.w; }
         if (b.w) { b.x += px * b.w; b.y += py * b.w; }
        }
       }
      }
     }

     // velocity update
     for (let i = 0; i < P.length; i++) {
      if (!P[i].active) continue;
      const p = P[i];
      p.vx = (p.x - p.px) / sdt;
      p.vy = (p.y - p.py) / sdt;
     }
    }
   }
   function stiffnessToCompliance(k_N_per_m) { return k_N_per_m > 0 ? 1 / k_N_per_m : 0; }
   return {
    P: Wd.P, C: Wd.C, T: Wd.T,
    get dt() { return Wd.dt; }, set dt(v) { Wd.dt = v; },
    get iters() { return Wd.iters; }, set iters(v) { Wd.iters = v | 0; },
    get substeps() { return Wd.substeps; }, set substeps(v) { Wd.substeps = v | 0; },
    get gravity() { return Wd.g; }, set gravity(g) { Wd.g = g; },
    get bounds() { return Wd.bounds; }, set bounds(b) { Wd.bounds = b; },
    get collide() { return Wd.collide; }, set collide(v) { Wd.collide = !!v; },
    add, setStatic, link, addForce, step, stiffnessToCompliance
   };
  }

  // =====================
  // Simulator (ALL physics)
  // =====================
  function makeSimulator() {
   const sim = XPBD({
    dt: TUNE.SIM.DT_S,
    iters: TUNE.SIM.ITERS,
    substeps: TUNE.SIM.SUBSTEPS,
    g: TUNE.SIM.GRAVITY_MPS2,
    bounds: TUNE.SIM.BOUNDS_M,
    collide: TUNE.SIM.COLLIDE_CIRCLES,
    contactCompliance: TUNE.SIM.CONTACT_COMPLIANCE_M_PER_N
   });

   // scene statics (physics coords in meters; renderer reads as-is)
   const [BX0, BY0, BX1, BY1] = TUNE.SIM.BOUNDS_M;
   const BW = BX1 - BX0, BH = BY1 - BY0;
   const platform = { r: 0.12, x1: BX0 + BW * 0.10, y1: BY0 + BH * 0.70, x2: BX0 + BW * 0.70, y2: BY0 + BH * 0.60 };
   const peg = { r: 0.20, x: BX0 + BW * 0.80, y: BY0 + BH * 0.40 };

   // rope + ball
   const N = TUNE.DEMO.ROPE_COUNT;
   const start = TUNE.DEMO.ROPE_START_M;
   const segLen = TUNE.DEMO.ROPE_SEG_LEN_M;
   const rope = [];
   let prev = sim.add(start.x, start.y, 0, TUNE.DEMO.ROPE_NODE_RADIUS_M, 0);
   rope.push(prev);
   for (let i = 1; i < N; i++) {
    const p = sim.add(start.x + i * segLen, start.y, TUNE.DEMO.ROPE_NODE_MASS_KG, TUNE.DEMO.ROPE_NODE_RADIUS_M, 0);
    sim.link(prev, p, segLen, sim.stiffnessToCompliance(TUNE.DEMO.ROPE_STIFFNESS_N_PER_M));
    rope.push(p);
    prev = p;
   }
   const ball = sim.add(TUNE.DEMO.BALL_POS_M.x, TUNE.DEMO.BALL_POS_M.y, TUNE.DEMO.BALL_MASS_KG, TUNE.DEMO.BALL_RADIUS_M, 1);

   // wound path (local to ball)
   function buildWoundPath(total, segLen_m, R_m) {
    const wX = new Array(total).fill(0), wY = new Array(total).fill(0);
    const inner = 0, outer = R_m;
    const locals = [];
    const pushFar = p => {
     if (!locals.length) { locals.push(p); return; }
     const q = locals[locals.length - 1], d = hypot(p.x - q.x, p.y - q.y);
     const nx = (p.x - q.x) / (d || 1), ny = (p.y - q.y) / (d || 1);
     locals.push({ x: q.x + nx * segLen_m, y: q.y + ny * segLen_m });
    };
    pushFar({ x: outer, y: outer });
    const limit = total - locals.length;
    let dir = 1;
    for (let i = 0; i < limit; i++) {
     if (random() < 0.2) { dir *= -1; }
     const angle = dir * i * (segLen_m / (2 * PI * outer)) * 2 * PI;
     const r = (outer - inner) * sqrt(1 - i / limit) + inner;
     const p = { x: r * cos(angle), y: r * sin(angle)};
     pushFar(p);
    }
    for (let i = 0; i < total; i++) { const p = locals[i] || locals[locals.length - 1]; wX[i] = p.x; wY[i] = p.y; }

    const wR = new Array(total).fill(0);
    for (let i = 1; i < total; i++) {
     wR[i] = hypot(wX[i], wY[i]);
    }
    return { wX, wY, wR };
   }
   const woundLocal = buildWoundPath(N, segLen, TUNE.DEMO.BALL_RADIUS_M);
   let freeCount = 0;

   function worldAnchor(i, cx, cy, ang = 0) {
    const ca = cos(ang), sa = sin(ang);
    const wx = cx + (woundLocal.wX[i] * ca - woundLocal.wY[i] * sa);
    const wy = cy + (woundLocal.wX[i] * sa + woundLocal.wY[i] * ca);
    return { x: wx, y: wy };
   }

   // initialize: place rope onto wound path, make all static
   (function layoutInitial() {
    for (let i = 0; i < N; i++) {
     const p = rope[i];
     p.w = 0; // static while on spool
    }
    rope[0].w = 0;
    freeCount = 0;
   })();

   function freeSegments(n = 1) {
    for (let k = 0; k < n && freeCount < N; k++) {
     const idx = freeCount;
     const p = rope[idx];
     p.w = 1 / TUNE.DEMO.ROPE_NODE_MASS_KG;          // make dynamic
     p.vx = ball.vx; p.vy = ball.vy;                 // inherit ball velocity
     p.col_mask = 2;
     freeCount++;
    }
    if (freeCount < N) {
     rope[freeCount].w = 0; // keep the next node pinned (static) to the wound path
     let totalRad = 0; // resize ball to size of yarn
     const limit = min(max(25, 0.1 * (N - freeCount)), N - freeCount);
     for (let i = 0; i < limit; i++) { totalRad += woundLocal.wR[i + freeCount]; }
     ball.r = max(0.05, totalRad / limit);
    } else {
     ball.active = false;
    }
   }

   // Physics advance: updates kinematic pins (wound nodes) and steps world
   function advance(dt) {
    // Update positions of all still-wound nodes including the "pin" node.
    if (freeCount < N) {
     const pin = rope[freeCount];
     const a0 = worldAnchor(freeCount, ball.x, ball.y, 0);
     pin.x = a0.x; pin.y = a0.y; pin.px = a0.x; pin.py = a0.y; // kinematic target
    }
    for (let i = freeCount + 1; i < N; i++) {
     const p = rope[i];
     const a = worldAnchor(i, ball.x, ball.y, 0);
     p.x = a.x; p.y = a.y; p.px = a.x; p.py = a.y; p.vx = 0; p.vy = 0; p.w = 0; // fully static wound
    }
    sim.step(dt);
   }

   function applyPoke(wx, wy, k = TUNE.DEMO.CLICK_POKE_N_PER_M) {
    sim.addForce(ball, (wx - ball.x) * k, (wy - ball.y) * k);
   }

   // Renderer-facing snapshot (read-only views)
   function getRenderData() {
    // Tail nodes are indices [0, freeCount]; wound polyline is the local wound beyond freeCount.
    const tailCount = Math.min(freeCount, N);
    const tail = [];
    for (let i = 0; i < tailCount; i++) tail.push({ x: rope[i].x, y: rope[i].y });
    // Build the world-space polyline of the remaining wound section for pretty drawing
    const wound = [];
    if (freeCount < N - 1) {
     for (let i = freeCount; i < N; i++) {
      const a = worldAnchor(i, ball.x, ball.y, 0);
      wound.push(a);
     }
    }
    // basic HUD numbers
    const freedLength_m = TUNE.DEMO.ROPE_SEG_LEN_M * freeCount;
    return {
     bounds: TUNE.SIM.BOUNDS_M.slice(),
     tail, wound,
     ball: { x: ball.x, y: ball.y, r: ball.r, active: ball.active },
     platform, peg,
     hud: { freedLength_m },
    };
   }

   return {
    advance, freeSegments, applyPoke, getRenderData
   };
  }

  // ==================================
  // Renderer (ALL graphics)
  // ==================================
  function makeRenderer() {
   const cfg = {
    pixelsPerMeter: TUNE.RENDER.PIXELS_PER_METER,
    bg: TUNE.RENDER.BG,
    linkStroke: TUNE.RENDER.LINK_STROKE,
    linkWidth: TUNE.RENDER.LINK_WIDTH_PX,
    showBounds: TUNE.RENDER.SHOW_BOUNDS
   };
   const S = cfg.pixelsPerMeter;

   function clear() {
    X.fillStyle = cfg.bg;
    X.fillRect(0, 0, C.clientWidth, C.clientHeight);
   }
   function toPx(bounds, x, y) {
    const [BX0, BY0] = bounds;
    return [(x - BX0) * S, (y - BY0) * S];
   }
   function toLen(lm) { return lm * S; }

   function drawBounds(bounds) {
    if (!cfg.showBounds) return;
    const [minx, miny, maxx, maxy] = bounds;
    X.strokeStyle = 'rgba(255,255,255,.2)';
    X.lineWidth = 1;
    X.strokeRect((minx-minx)*S, (miny-miny)*S, (maxx-minx)*S, (maxy-miny)*S);
   }

   function drawStaticsAndHUD(state) {
    const {bounds, platform, peg, ball, hud} = state;
    const [BX0, _, BX1, BY1] = bounds;

    // floor
    X.strokeStyle = '#444'; X.lineWidth = 0.05 * S;
    X.beginPath();
    let p0 = toPx(bounds, BX0, BY1); let p1 = toPx(bounds, BX1, BY1);
    X.moveTo(p0[0], p0[1]); X.lineTo(p1[0], p1[1]); X.stroke();

    // platform
    X.strokeStyle = '#666'; X.lineCap = 'round'; X.lineWidth = platform.r * S;
    p0 = toPx(bounds, platform.x1, platform.y1); p1 = toPx(bounds, platform.x2, platform.y2);
    X.beginPath(); X.moveTo(p0[0], p0[1]); X.lineTo(p1[0], p1[1]); X.stroke();

    // peg
    const pegPx = toPx(bounds, peg.x, peg.y);
    X.fillStyle = '#666';
    X.beginPath(); X.arc(pegPx[0], pegPx[1], toLen(peg.r), 0, Math.PI * 2); X.fill();

    // draw dotted outline of ball
    if (ball.active) {
     const ballPx = toPx(bounds, ball.x, ball.y);
     X.strokeStyle = 'rgba(255,255,255)';
     X.lineWidth = 1;
     X.setLineDash([4, 4]);
     X.beginPath();
     X.arc(ballPx[0], ballPx[1], toLen(ball.r), 0, Math.PI * 2);
     X.stroke();
     X.setLineDash([]);
    }
    // HUD
    X.fillStyle = '#fff'; X.font = '14px system-ui,sans-serif';
    X.fillText('yarn: ' + hud.freedLength_m.toFixed(1) + ' m', 12, 22);
   }

   function dist(a, b) {
    const dx = b[0] - a[0], dy = b[1] - a[1];
    return Math.hypot(dx, dy);
   }

   function catmullRomToBezier(ctx, pts, tension = 1) {
    if (!pts || pts.length < 2) return;

    // Duplicate endpoints to handle ends naturally
    const P = [pts[0], ...pts, pts[pts.length - 1]];

    // Parametrize (centripetal): u_{i+1} = u_i + |P_{i+1}-P_i|^0.5
    const u = new Array(P.length).fill(0);
    for (let i = 1; i < P.length; i++) {
     u[i] = u[i - 1] + Math.pow(dist(P[i - 1], P[i]), 0.5);
    }

    // Start path
    ctx.beginPath();
    ctx.moveTo(pts[0][0], pts[0][1]);

    for (let i = 1; i < P.length - 2; i++) {
     const P0 = P[i - 1], P1 = P[i], P2 = P[i + 1], P3 = P[i + 2];

     const u0 = u[i - 1], u1 = u[i], u2 = u[i + 1], u3 = u[i + 2];
     const du01 = u1 - u0 || 1, du12 = u2 - u1 || 1, du23 = u3 - u2 || 1;

     // Tangents with centripetal parameterization
     const m1 = {
      x: ((P2[0] - P1[0]) / du12 - (P1[0] - P0[0]) / du01) * du12 + (P2[0] - P1[0]) / du12,
      y: ((P2[1] - P1[1]) / du12 - (P1[1] - P0[1]) / du01) * du12 + (P2[1] - P1[1]) / du12,
     };
     const m2 = {
      x: ((P3[0] - P2[0]) / du23 - (P2[0] - P1[0]) / du12) * du12 + (P2[0] - P1[0]) / du12,
      y: ((P3[1] - P2[1]) / du23 - (P2[1] - P1[1]) / du12) * du12 + (P2[1] - P1[1]) / du12,
     };

     // Scale tangents by tension (1 = standard Catmull–Rom; smaller tightens the curve)
     const t = tension / 6;
     const c1 = { x: P1[0] + m1.x * t, y: P1[1] + m1.y * t };
     const c2 = { x: P2[0] - m2.x * t, y: P2[1] - m2.y * t };

     ctx.bezierCurveTo(c1.x, c1.y, c2.x, c2.y, P2[0], P2[1]);
    }

    ctx.stroke();
   }


   function drawYarn(state) {
    const {bounds, tail, wound} = state;
    const m = tail.concat(wound), n = m.length;
    if (n < 2) return;
    for (let i = 0; i < n; i++) {
     m[i] = toPx(bounds, m[i].x, m[i].y);
    }
    X.save();
    X.lineCap = 'round'; X.lineJoin = 'round'; X.strokeStyle = cfg.linkStroke; X.lineWidth = cfg.linkWidth;
    catmullRomToBezier(X, m, 5);
    X.restore();
   }

   function draw(state) {
    clear();
    drawBounds(state.bounds);
    drawYarn(state);
    drawStaticsAndHUD(state);
   }

   function screenToMeters(bounds, clientX, clientY) {
    const rect = C.getBoundingClientRect();
    const lx = (clientX - rect.left) / DPR;
    const ly = (clientY - rect.top) / DPR;
    const [BX0, BY0] = bounds;
    return { x: BX0 + lx / S, y: BY0 + ly / S };
   }

   return { draw, screenToMeters };
  }

  // =====================
  // Wire-up: sim + renderer
  // =====================
  const simCtl = makeSimulator();
  const renderer = makeRenderer();

  // =====================
  // Animate (pure orchestration)
  // =====================
  fitCanvasToWindow();
  let last = performance.now();
  function tick(t) {
   const dt = clamp((t - last) / 1000, 0, TUNE.DEMO.MAX_FRAME_DT_S);
   last = t;

   // physics
   simCtl.advance(dt);

   // render
   const state = simCtl.getRenderData();
   renderer.draw(state);

   requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  // =====================
  // Input: click applies a force + frees segments
  // =====================
  C.addEventListener('click', e => {
   const state = simCtl.getRenderData();
   const wp = renderer.screenToMeters(state.bounds, e.clientX, e.clientY);
   simCtl.applyPoke(wp.x, wp.y, TUNE.DEMO.CLICK_POKE_N_PER_M);
   simCtl.freeSegments(10);
  });
 });
</script>
