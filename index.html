<div id="app"></div>
<script>
  let signal = null;

  // ========================================
  // CONFIG: TUNABLE
  // ========================================
  const TUNE = {
    SIM: {
      DT_S:                1/60,
      SUBSTEPS:            1,
      ITERS:               18,              // a few more helps the chain
      GRAVITY_MPS2:        [0, 9.81],
      DRAG:                0.01,
      BOUNDS_M:            [0, 0, 8, 6],
      COLLIDE_CIRCLES:     true,
      CONTACT_COMPLIANCE_M_PER_N: 0
    },
    RENDER: {
      WIDTH_PX:            800,
      HEIGHT_PX:           600,
      PIXELS_PER_METER:    100,
      BG:                  '#0b0d12',
      LINK_STROKE:         '#6aa9ff',
      LINK_WIDTH_PX:       2,
      PARTICLE_FILL:       '#ffd166',
      PARTICLE_STROKE:     '#222',
      PARTICLE_STROKE_W:   1,
      PIN_FILL:            '#ff6b6b',
      SHOW_BOUNDS:         true,
      BOUNDS_STROKE:       'rgba(255,255,255,.2)',
      DEFAULT_PARTICLE_R_M:0.05
    },
    DEMO: {
      ROPE_COUNT:          40,
      ROPE_START_M:        {x: 4, y: 0.8},
      ROPE_SEG_LEN_M:      0.10,
      ROPE_NODE_MASS_KG:   0.01,
      ROPE_NODE_RADIUS_M:  0.05,
      ROPE_STIFFNESS_N_PER_M: 1e8,

      BALL_POS_M:          {x: 6, y: 4.3},
      BALL_RADIUS_M:       0.30,
      BALL_MASS_KG:        2,

      MAX_FRAME_DT_S:      1/30,
      CLICK_POKE_N_PER_M:  300
    }
  };

  // ========================================
  // CONFIG: NON_TUNABLE
  // ========================================
  const INTERNAL = {
    EPS_M:         1e-9,
    MIN_VIEWBOX_W: 1,
    MIN_VIEWBOX_H: 1,
    LAMBDA_DECAY:      1.0   // set <1 to bleed warmstart if needed
  };

  // =========================
  // XPBD (SI Units, meters)
  // =========================
  function XPBD(opt = {}) {
    const W = {
      dt: opt.dt ?? TUNE.SIM.DT_S,
      substeps: opt.substeps ?? TUNE.SIM.SUBSTEPS,
      iters: opt.iters ?? TUNE.SIM.ITERS,
      g: opt.g ?? TUNE.SIM.GRAVITY_MPS2.slice(),
      drag: opt.drag ?? TUNE.SIM.DRAG,
      bounds: opt.bounds ?? (TUNE.SIM.BOUNDS_M && TUNE.SIM.BOUNDS_M.slice()),
      contactCompliance: opt.contactCompliance ?? TUNE.SIM.CONTACT_COMPLIANCE_M_PER_N,
      collide: opt.collide ?? TUNE.SIM.COLLIDE_CIRCLES,
      P: [],  // particles
      C: [],  // distance constraints (equality)
      T: []   // tethers (inequality)
    };

    // --- Particles ---
    function add(x_m, y_m, mass_kg = 1, radius_m = 0) {
      const w = mass_kg > 0 ? 1 / mass_kg : 0;
      const p = { x: x_m, y: y_m, px: x_m, py: y_m, vx: 0, vy: 0, w, r: radius_m };
      W.P.push(p);
      return p;
    }
    function setStatic(p, yes = true) { p.w = yes ? 0 : (p.w || 1); }

    // --- Distance (XPBD, equality) ---
    function link(a, b, rest_m = null, compliance_m_per_N = 0) {
      if (rest_m == null) { const dx = b.x - a.x, dy = b.y - a.y; rest_m = Math.hypot(dx, dy); }
      const c = { a, b, rest: rest_m, comp: compliance_m_per_N, lam: 0 };
      W.C.push(c);
      return c;
    }

    // --- Forces (N) ---
    function addForce(p, Fx_N, Fy_N) {
      if (!p.w) return p;
      p.vx += (Fx_N * p.w) * W.dt;
      p.vy += (Fy_N * p.w) * W.dt;
      return p;
    }

    // --- Solver step ---
    function step(dt = W.dt) {
      const P = W.P, C = W.C, T = W.T, g = W.g, drag = W.drag, sub = W.substeps, it = W.iters;
      const hasBounds = !!W.bounds, B = W.bounds;
      const doCollide = !!W.collide, cComp = W.contactCompliance;

      const sdt = dt / sub;
      const invDrag = 1 / (1 + drag);
      const alphaScale = sdt * sdt;

      for (let s = 0; s < sub; s++) {
        // integrate
        for (let i = 0; i < P.length; i++) {
          const p = P[i];
          p.px = p.x; p.py = p.y;
          if (!p.w) continue;
          p.vx += g[0] * sdt; p.vy += g[1] * sdt;
          p.vx *= invDrag;    p.vy *= invDrag;
          p.x += p.vx * sdt;  p.y += p.vy * sdt;
        }

        // GS iterations
        for (let k = 0; k < it; k++) {
          // Tethers (inequality: ||a-b|| <= max). Define C = max - d.
          for (let i = 0; i < T.length; i++) {
            const t = T[i], a = t.a, b = t.b;
            let dx = a.x - b.x, dy = a.y - b.y;
            let d = Math.hypot(dx, dy); if (d < INTERNAL.EPS_M) d = INTERNAL.EPS_M;
            const Cval = t.max - d;                    // active when Cval < 0 (overstretched)
            if (Cval >= 0) { t.lam = 0; continue; }    // inactive: reset λ (KKT)
            const nx = dx / d, ny = dy / d;
            const wsum = a.w + b.w; if (wsum === 0) continue;
            // XPBD with damping: α = c/dt^2 + d/dt
            const alpha = (t.comp || 0) / alphaScale;
            const oldLam = Math.max(0, t.lam) * INTERNAL.LAMBDA_DECAY;
            let dlam = (-Cval - alpha * oldLam) / (wsum + alpha);
            let newLam = oldLam + dlam;
            if (newLam < 0) { dlam = -oldLam; newLam = 0; } // project λ ≥ 0
            const px = dlam * nx, py = dlam * ny;
            if (a.w) { a.x -= px * a.w; a.y -= py * a.w; }
            if (b.w) { b.x += px * b.w; b.y += py * b.w; }
            t.lam = newLam;
          }

          // Distance constraints
          for (let i = 0; i < C.length; i++) {
            const c = C[i], a = c.a, b = c.b;
            let dx = b.x - a.x, dy = b.y - a.y;
            let d = Math.hypot(dx, dy);
            if (d < INTERNAL.EPS_M) continue;
            const nx = dx / d, ny = dy / d;
            const Cval = d - c.rest;
            const wsum = a.w + b.w;
            if (wsum === 0) { c.lam = 0; continue; }
            const alpha = (c.comp || 0) / alphaScale;
            const oldLam = c.lam * INTERNAL.LAMBDA_DECAY;
            const dlam = (-Cval - alpha * oldLam) / (wsum + alpha);
            c.lam = oldLam + dlam;
            const px = dlam * nx, py = dlam * ny;
            if (a.w) { a.x -= px * a.w; a.y -= py * a.w; }
            if (b.w) { b.x += px * b.w; b.y += py * b.w; }
          }

          // Bounds (AABB)
          if (hasBounds) {
            const [minx, miny, maxx, maxy] = B;
            for (let i = 0; i < P.length; i++) {
              const p = P[i], r = p.r || 0;
              if (p.x < minx + r) p.x = minx + r;
              if (p.x > maxx - r) p.x = maxx - r;
              if (p.y < miny + r) p.y = miny + r;
              if (p.y > maxy - r) p.y = maxy - r;
            }
          }

          // Optional circle–circle contacts
          if (doCollide) {
            const alphaC = (cComp || 0) / alphaScale;
            for (let i = 0; i < P.length; i++) {
              const a = P[i]; if (!a.r) continue;
              for (let j = i + 1; j < P.length; j++) {
                const b = P[j]; if (!b.r) continue;
                let dx = b.x - a.x, dy = b.y - a.y;
                let d = Math.hypot(dx, dy); if (d < INTERNAL.EPS_M) d = INTERNAL.EPS_M;
                const rs = (a.r || 0) + (b.r || 0);
                const Cval = d - rs; if (Cval >= 0) continue;
                const nx = dx / d, ny = dy / d;
                const wsum = a.w + b.w; if (wsum === 0) continue;
                const dlam = (-Cval) / (wsum + alphaC);
                const px = dlam * nx, py = dlam * ny;
                if (a.w) { a.x -= px * a.w; a.y -= py * a.w; }
                if (b.w) { b.x += px * b.w; b.y += py * b.w; }
              }
            }
          }
        }

        // velocity update
        for (let i = 0; i < P.length; i++) {
          const p = P[i];
          p.vx = (p.x - p.px) / sdt;
          p.vy = (p.y - p.py) / sdt;
        }
      }
    }

    function stiffnessToCompliance(k_N_per_m) { return k_N_per_m > 0 ? 1 / k_N_per_m : 0; }

    return {
      P: W.P, C: W.C, T: W.T,
      get dt() { return W.dt; }, set dt(v) { W.dt = v; },
      get iters() { return W.iters; }, set iters(v) { W.iters = v | 0; },
      get substeps() { return W.substeps; }, set substeps(v) { W.substeps = v | 0; },
      get gravity() { return W.g; }, set gravity(g) { W.g = g; },
      get bounds() { return W.bounds; }, set bounds(b) { W.bounds = b; },
      get collide() { return W.collide; }, set collide(v) { W.collide = !!v; },
      add, setStatic, link, addForce, step, stiffnessToCompliance
    };
  }

  // ==================================
  // Minimal SVG Renderer (meters↔pixels)
  // ==================================
  function SVGRenderer(sim, opt = {}) {
    const cfg = {
      container: opt.container || document.body,
      width: opt.width ?? TUNE.RENDER.WIDTH_PX,
      height: opt.height ?? TUNE.RENDER.HEIGHT_PX,
      pixelsPerMeter: opt.pixelsPerMeter ?? TUNE.RENDER.PIXELS_PER_METER,
      bg: opt.bg || TUNE.RENDER.BG,
      linkStroke: opt.linkStroke || TUNE.RENDER.LINK_STROKE,
      linkWidth: opt.linkWidth ?? TUNE.RENDER.LINK_WIDTH_PX,
      particleFill: opt.particleFill || TUNE.RENDER.PARTICLE_FILL,
      particleStroke: opt.particleStroke || TUNE.RENDER.PARTICLE_STROKE,
      particleWidth: opt.particleWidth ?? TUNE.RENDER.PARTICLE_STROKE_W,
      pinFill: opt.pinFill || TUNE.RENDER.PIN_FILL,
      showBounds: opt.showBounds ?? TUNE.RENDER.SHOW_BOUNDS,
      defaultRadiusM: opt.defaultRadiusM ?? TUNE.RENDER.DEFAULT_PARTICLE_R_M
    };

    const S = cfg.pixelsPerMeter;
    const svgNS = 'http://www.w3.org/2000/svg';
    const svg = document.createElementNS(svgNS, 'svg');
    svg.setAttribute('width', String(cfg.width));
    svg.setAttribute('height', String(cfg.height));
    svg.style.display = 'block';
    svg.style.background = cfg.bg;
    svg.setAttribute('viewBox', `0 0 ${cfg.width} ${cfg.height}`);

    const gLinks = document.createElementNS(svgNS, 'g');
    const gParticles = document.createElementNS(svgNS, 'g');
    const gOverlay = document.createElementNS(svgNS, 'g');
    svg.append(gLinks, gParticles, gOverlay);
    cfg.container.appendChild(svg);

    function origin() {
      if (!sim.bounds) return [0, 0];
      const [minx, miny] = sim.bounds;
      return [minx, miny];
    }
    function toPxX(xm) { const [ox] = origin(); return (xm - ox) * S; }
    function toPxY(ym) { const [, oy] = origin(); return (ym - oy) * S; }
    function toPxLen(lm) { return lm * S; }

    function toMeters(px, py) {
      const [ox, oy] = origin();
      return { x: ox + px / S, y: oy + py / S };
    }

    function drawBounds() {
      gOverlay.innerHTML = '';
      if (!cfg.showBounds || !sim.bounds) return;
      const [minx, miny, maxx, maxy] = sim.bounds;
      const w = Math.max(INTERNAL.MIN_VIEWBOX_W, maxx - minx);
      const h = Math.max(INTERNAL.MIN_VIEWBOX_H, maxy - miny);
      const r = document.createElementNS(svgNS, 'rect');
      r.setAttribute('x', String(toPxX(minx)));
      r.setAttribute('y', String(toPxY(miny)));
      r.setAttribute('width', String(toPxLen(w)));
      r.setAttribute('height', String(toPxLen(h)));
      r.setAttribute('fill', 'none');
      r.setAttribute('stroke', TUNE.RENDER.BOUNDS_STROKE);
      r.setAttribute('stroke-width', '1');
      gOverlay.appendChild(r);
    }

    function draw() {
      const C = sim.C, P = sim.P;
      gLinks.innerHTML = '';
      for (let i = 0; i < C.length; i++) {
        const c = C[i], a = c.a, b = c.b;
        const line = document.createElementNS(svgNS, 'line');
        line.setAttribute('x1', String(toPxX(a.x))); line.setAttribute('y1', String(toPxY(a.y)));
        line.setAttribute('x2', String(toPxX(b.x))); line.setAttribute('y2', String(toPxY(b.y)));
        line.setAttribute('stroke', cfg.linkStroke);
        line.setAttribute('stroke-width', String(cfg.linkWidth));
        line.setAttribute('stroke-linecap', 'round');
        gLinks.appendChild(line);
      }
      gParticles.innerHTML = '';
      for (let i = 0; i < P.length; i++) {
        const p = P[i], r_px = toPxLen(p.r || cfg.defaultRadiusM);
        const cir = document.createElementNS(svgNS, 'circle');
        cir.setAttribute('cx', String(toPxX(p.x))); cir.setAttribute('cy', String(toPxY(p.y)));
        cir.setAttribute('r', String(r_px));
        cir.setAttribute('fill', p.w ? cfg.particleFill : cfg.pinFill);
        cir.setAttribute('stroke', cfg.particleStroke);
        cir.setAttribute('stroke-width', String(cfg.particleWidth));
        gParticles.appendChild(cir);
      }
      drawBounds();
    }

    function resize(w, h) {
      if (w) cfg.width = w;
      if (h) cfg.height = h;
      svg.setAttribute('width', String(cfg.width));
      svg.setAttribute('height', String(cfg.height));
      svg.setAttribute('viewBox', `0 0 ${cfg.width} ${cfg.height}`);
      drawBounds();
    }

    function screenToMeters(clientX, clientY) {
      const pt = svg.createSVGPoint();
      pt.x = clientX; pt.y = clientY;
      const local = pt.matrixTransform(svg.getScreenCTM().inverse());
      return toMeters(local.x, local.y);
    }

    return { svg, draw, resize, config: cfg, screenToMeters };
  }

  // =====================
  // Demo (SI units)
  // =====================
  const sim = XPBD({
    dt: TUNE.SIM.DT_S,
    iters: TUNE.SIM.ITERS,
    substeps: TUNE.SIM.SUBSTEPS,
    g: TUNE.SIM.GRAVITY_MPS2,
    bounds: TUNE.SIM.BOUNDS_M,
    collide: TUNE.SIM.COLLIDE_CIRCLES,
    contactCompliance: TUNE.SIM.CONTACT_COMPLIANCE_M_PER_N
  });

  // Build a rope
  const N = TUNE.DEMO.ROPE_COUNT;
  const start = TUNE.DEMO.ROPE_START_M;
  const dx = TUNE.DEMO.ROPE_SEG_LEN_M, dy = 0;
  const rope = [];
  let prev = sim.add(start.x, start.y, 0, TUNE.DEMO.ROPE_NODE_RADIUS_M); // pinned
  rope.push(prev);
  for (let i = 1; i < N; i++) {
    const p = sim.add(start.x + i*dx, start.y + i*dy, TUNE.DEMO.ROPE_NODE_MASS_KG, TUNE.DEMO.ROPE_NODE_RADIUS_M);
    sim.link(prev, p, dx, sim.stiffnessToCompliance(TUNE.DEMO.ROPE_STIFFNESS_N_PER_M));
    rope.push(p);
    prev = p;
  }

  // A ball
  const ball = sim.add(
    TUNE.DEMO.BALL_POS_M.x,
    TUNE.DEMO.BALL_POS_M.y,
    TUNE.DEMO.BALL_MASS_KG,
    TUNE.DEMO.BALL_RADIUS_M
  );

  // Renderer
  const r = SVGRenderer(sim, {
    container: document.getElementById('app'),
    width: TUNE.RENDER.WIDTH_PX,
    height: TUNE.RENDER.HEIGHT_PX,
    pixelsPerMeter: TUNE.RENDER.PIXELS_PER_METER
  });

  // Animate
  let last = performance.now();
  function tick(t) {
    const dt = Math.min(TUNE.DEMO.MAX_FRAME_DT_S, (t - last) / 1000);
    last = t;
    sim.step(dt);
    r.draw();
    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  // Click to apply a force toward the click point (N)
  r.svg.addEventListener('click', e => {
    const wp = r.screenToMeters(e.clientX, e.clientY);
    const k = TUNE.DEMO.CLICK_POKE_N_PER_M;
    sim.addForce(ball, (wp.x - ball.x) * k, (wp.y - ball.y) * k);
    signal = 'click';
  });
</script>
