<script>
  document.addEventListener('DOMContentLoaded', () => {
    // ===== Canvas bootstrap =====
    const $ = document, W = window, B = $.body, C = $.createElement('canvas'), X = C.getContext('2d');
    (document.getElementById('content') || B).innerHTML = '';
    Object.assign(B.style, {margin: 0, overflow: 'hidden'});
    Object.assign(C.style, {display: 'block', touchAction: 'none'});
    B.appendChild(C);

    // ===== Math helpers =====
    const {min, max, hypot, sin, cos, PI, atan2, random} = Math;
    const clamp = (v, a, b) => max(a, min(b, v));
    const midpoint = (a, b) => 0.5*(a+b);

    // ===== World / DPI =====
    const DPR = min(2, W.devicePixelRatio || 1), world = {w: 0, h: 0};

    // Forward declarations for things used in resize()
    let sim, platform, peg;

    const resize = () => {
      const w = W.innerWidth || $.documentElement.clientWidth;
      const h = W.innerHeight || $.documentElement.clientHeight;
      Object.assign(C.style, {width: w+'px', height: h+'px'});
      C.width = (w*DPR)|0; C.height=(h*DPR)|0;
      X.setTransform(DPR,0,0,DPR,0,0);
      world.w = C.clientWidth; world.h = C.clientHeight;

      // relayout statics
      platform.x1 = world.w*0.1; platform.y1 = world.h*0.70;
      platform.x2 = world.w*0.7; platform.y2 = world.h*0.60;
      peg.x = world.w*0.80; peg.y = world.h*0.40;

      if (sim){
        sim.bounds = {w: world.w, h: world.h};
        if (sim.staticSegs[0]){
          sim.staticSegs[0].x1 = platform.x1; sim.staticSegs[0].y1 = platform.y1;
          sim.staticSegs[0].x2 = platform.x2; sim.staticSegs[0].y2 = platform.y2;
          sim.staticSegs[0].r  = platform.r;
        }
        if (sim.staticCircs[0]){
          sim.staticCircs[0].x = peg.x; sim.staticCircs[0].y = peg.y; sim.staticCircs[0].r = peg.r;
        }
      }
    };
    W.addEventListener('resize', resize);

    // ===== XPBD core =====
    class XPBDSim {
      constructor(opts){
        this.g = opts.g ?? 1600;
        this.air = opts.air ?? 0.997;
        this.rest = opts.rest ?? 0.55;
        this.wall = opts.wall ?? 0.5;
        this.mu   = opts.mu ?? 0.4;
        this.alphaDist = opts.alphaDist ?? 1e-6;
        this.alphaContact = opts.alphaContact ?? 1e-6;
        this.maxSub = opts.maxSub ?? 12;
        this.cfl = opts.cfl ?? 0.3;
        this.iters = opts.iters ?? 8;
        this.bounds = {w: 0, h: 0};

        this.p = [];          // particles
        this.edges = [];      // [{i,j,len, lambda}]
        this.capsuleRadius = opts.capsuleRadius ?? 2;
        this.staticSegs = []; // {x1,y1,x2,y2,r}
        this.staticCircs = []; // {x,y,r}
        this.staticBoxes = []; // {x,y,w,h}
        this.circles = [];    // dynamic circles {id, r, pi}
      }
      addParticle(x,y, invM){
        const i = this.p.length;
        this.p.push({x,y, px:x,py:y, vx:0,vy:0, invM});
        return i;
      }
      addCircle(x,y,r, invM){
        const i = this.addParticle(x,y, invM);
        const id = this.circles.length;
        this.circles.push({id, r, pi: i});
        return {id, r, pi:i};
      }
      addEdge(i,j,len){ this.edges.push({i,j,len, lambda:0}); }
      addStaticSegment(x1,y1,x2,y2,r=0){ this.staticSegs.push({x1,y1,x2,y2,r}); }
      addStaticCircle(x,y,r){ this.staticCircs.push({x,y,r}); }
      addStaticBox(x,y,w,h){ this.staticBoxes.push({x,y,w,h}); }

      // --- geometry helpers ---
      closestPointOnSeg(ax,ay,bx,by, px,py){
        const abx=bx-ax, aby=by-ay, apx=px-ax, apy=py-ay;
        const ab2 = abx*abx + aby*aby || 1e-12;
        let t=(apx*abx+apy*aby)/ab2; t=clamp(t,0,1);
        return {x: ax + abx*t, y: ay + aby*t, t};
      }
      segSegClosest(ax,ay,bx,by, cx,cy,dx,dy){
        const ux=bx-ax, uy=by-ay;
        const vx=dx-cx, vy=dy-cy;
        const wx=ax-cx, wy=ay-cy;
        const a=ux*ux+uy*uy, b=ux*vx+uy*vy, c=vx*vx+vy*vy, d=ux*wx+uy*wy, e=vx*wx+vy*wy;
        const D=a*c-b*b;
        let sc, sN, sD=D, tc, tN, tD=D;
        if (D<1e-10){ sN=0; sD=1; tN=e; tD=c; }
        else { sN=(b*e-c*d); tN=(a*e-b*d);
          if (sN<0){ sN=0; tN=e; tD=c; }
          else if (sN>sD){ sN=sD; tN=e+b; tD=c; }
        }
        if (tN<0){ tN=0; if (-d<0) sc=0; else if (-d>a) sc=1; else sc=-d/a; }
        else if (tN>tD){ tN=tD; if ((-d+b)<0) sc=0; else if ((-d+b)>a) sc=1; else sc=(-d+b)/a; }
        else sc=(Math.abs(sD)<1e-10?0:sN/sD);
        tc=(Math.abs(tD)<1e-10?0:tN/tD);
        const px=ax+sc*ux, py=ay+sc*uy, qx=cx+tc*vx, qy=cy+tc*vy;
        const dxq=px-qx, dyq=py-qy; const dist=hypot(dxq,dyq)||1e-12;
        return {px,py,qx,qy,s:sc,t:tc,dist};
      }
      collideCapsuleSegment(ax,ay,bx,by, rr, x1,y1,x2,y2, sr=0){
        const c=this.segSegClosest(ax,ay,bx,by, x1,y1,x2,y2);
        const d=c.dist||1e-12, pen=(rr+sr)-d;
        if (pen>0){ return {nx:(c.px-c.qx)/d, ny:(c.py-c.qy)/d, pen, s:c.s}; }
        return null;
      }
      collideCapsuleCircle(ax,ay,bx,by, rr, cx,cy, cr){
        const p=this.closestPointOnSeg(ax,ay,bx,by, cx,cy);
        let dx=p.x-cx, dy=p.y-cy; const d=hypot(dx,dy)||1e-12;
        const pen=(rr+cr)-d;
        if (pen>0){ return {nx:dx/d, ny:dy/d, pen, s:p.t}; }
        return null;
      }
      collideCapsuleAABB(ax,ay,bx,by, rr, cx,cy, hw,hh){
        let best=null, bestPen=-1;
        const L=cx-hw, R=cx+hw, T=cy-hh, B=cy+hh;
        const edges=[[L,T,R,T],[R,T,R,B],[R,B,L,B],[L,B,L,T]];
        for(const [ex1,ey1,ex2,ey2] of edges){
          const hit=this.collideCapsuleSegment(ax,ay,bx,by, rr, ex1,ey1,ex2,ey2, 0);
          if (hit && hit.pen>bestPen){ bestPen=hit.pen; best=hit; }
        }
        return best;
      }
      // Circle vs static helpers (for the yarn ball)
      circleVsSegment(cx,cy,cr, x1,y1,x2,y2, sr=0){
        const p=this.closestPointOnSeg(x1,y1,x2,y2, cx,cy);
        const dx=cx-p.x, dy=cy-p.y, d=hypot(dx,dy)||1e-12;
        const pen = (cr + sr) - d;
        if (pen>0) return {nx:dx/d, ny:dy/d, pen};
        return null;
      }
      circleVsCircle(ax,ay,ar, bx,by,br){
        const dx=bx-ax, dy=by-ay, d=hypot(dx,dy)||1e-12;
        const pen = (ar+br) - d;
        if (pen>0) return {nx:dx/d, ny:dy/d, pen};
        return null;
      }
      circleVsAABB(cx,cy,cr, bx,by, hw,hh){
        const nx=clamp(cx, bx-hw, bx+hw);
        const ny=clamp(cy, by-hh, by+hh);
        const dx=cx-nx, dy=cy-ny, d=hypot(dx,dy)||1e-12;
        const pen = cr - d;
        if (pen>0) return {nx:dx/d, ny:dy/d, pen};
        return null;
      }

      // --- step ---
      step(dt, ropeRange, ropeRadius, pinIndex, pinPos){
        const N = this.p.length;

        // ===== Integrate (semi-implicit Euler) =====
        for (let i=0;i<N;i++){
          const a = this.p[i];
          a.px = a.x; a.py = a.y;
          if (a.invM){
            a.vy += this.g * dt * dt;
            a.x  += a.vx * dt;
            a.y  += a.vy * dt;
          }
          // screen bounds (dynamic only)
          if (a.invM){
            const W = this.bounds.w, H=this.bounds.h;
            if (a.y > H){ a.y = H; a.vy *= -this.rest; a.vx *= (1-this.mu); }
            if (a.y < 0){ a.y = 0; a.vy *= -this.wall; }
            if (a.x < 0){ a.x = 0; a.vx *= -this.wall; }
            if (a.x > W){ a.x = W; a.vx *= -this.wall; }
          }
        }

        // keep a rope node pinned (anchor)
        if (pinIndex != null && pinIndex >= 0){
          const p = this.p[pinIndex];
          p.x = pinPos.x; p.y = pinPos.y;
          p.vx = 0; p.vy = 0;
        }

        // ===== Adaptive substeps =====
        let vmax = 0, rmin = ropeRadius || this.capsuleRadius;
        const [ri0, ri1] = ropeRange || [0, -1];
        if (ri1 >= ri0){
          for (let i=ri0;i<=ri1;i++){
            const a=this.p[i]; vmax = Math.max(vmax, hypot(a.vx, a.vy));
          }
        }
        for (const s of this.staticCircs) rmin = Math.min(rmin, s.r);
        for (const s of this.staticSegs) rmin = Math.min(rmin, s.r || rmin);
        for (const b of this.staticBoxes) rmin = Math.min(rmin, Math.min(b.w*0.5, b.h*0.5));
        for (const c of this.circles) rmin = Math.min(rmin, c.r);
        rmin = Math.max(1, rmin);
        let sub = Math.max(1, Math.min(this.maxSub, Math.ceil((vmax*dt)/(this.cfl*rmin))));
        const dtSub = dt / sub;
        const K = Math.max(3, this.iters|0);

        for (let s=0;s<sub;s++){
          // --- Distance constraints (warm-started XPBD)
          for (const e of this.edges){
            const A=this.p[e.i], B=this.p[e.j];
            const wi=A.invM, wj=B.invM; if (!(wi||wj)) continue;
            let dx=B.x-A.x, dy=B.y-A.y;
            const L=hypot(dx,dy)||1e-12;
            const nx=dx/L, ny=dy/L;
            const C = L - e.len;
            if (Math.abs(C)<1e-7) continue;
            const w = wi+wj;
            const alpha = this.alphaDist / (dtSub*dtSub + 1e-18);
            const dl = ( -C - alpha*e.lambda) / (w + alpha);
            e.lambda += dl;
            if (wi){ A.x -= dl*wi*nx; A.y -= dl*wi*ny; }
            if (wj){ B.x += dl*wj*nx; B.y += dl*wj*ny; }
          }

          // --- Build capsules for free rope portion
          const caps=[];
          const rr = ropeRadius || this.capsuleRadius;
          for (const e of this.edges){
            if (ri1>=ri0 && !(e.i>=ri0 && e.j<=ri1)) continue;
            const A=this.p[e.i], B=this.p[e.j];
            caps.push({e, ax:A.x,ay:A.y, bx:B.x,by:B.y, rr});
          }

          // --- Contact candidates (speculative)
          const contacts=[];
          for (const cap of caps){
            const Ai=this.p[cap.e.i], Bi=this.p[cap.e.j];
            const sv = 0.5*(hypot(Ai.vx, Ai.vy) + hypot(Bi.vx, Bi.vy));
            const rrSpec = cap.rr + sv * (dtSub / (dt + 1e-18));
            let best=null, bestPen=-1, bestKind='';
            for (const sSeg of this.staticSegs){
              const hit=this.collideCapsuleSegment(cap.ax,cap.ay,cap.bx,cap.by, rrSpec, sSeg.x1,sSeg.y1,sSeg.x2,sSeg.y2, sSeg.r||0);
              if (hit && hit.pen>bestPen){ best=hit; bestPen=hit.pen; bestKind='seg'; }
            }
            for (const sCir of this.staticCircs){
              const hit=this.collideCapsuleCircle(cap.ax,cap.ay,cap.bx,cap.by, rrSpec, sCir.x,sCir.y,sCir.r);
              if (hit && hit.pen>bestPen){ best=hit; bestPen=hit.pen; bestKind='scirc'; }
            }
            for (const sBox of this.staticBoxes){
              const hit=this.collideCapsuleAABB(cap.ax,cap.ay,cap.bx,cap.by, rrSpec, sBox.x,sBox.y,sBox.w*0.5,sBox.h*0.5);
              if (hit && hit.pen>bestPen){ best=hit; bestPen=hit.pen; bestKind='sbox'; }
            }
            for (const d of this.circles){
              const C=this.p[d.pi];
              if (d.pi===cap.e.i || d.pi===cap.e.j) continue;
              const hit=this.collideCapsuleCircle(cap.ax,cap.ay,cap.bx,cap.by, rrSpec, C.x,C.y,d.r);
              if (hit && hit.pen>bestPen){ best=hit; bestPen=hit.pen; bestKind='dcirc'; best.dyn = d; }
            }
            if (best){ contacts.push({cap, hit:best, kind:bestKind, lambda:0}); }
          }

          // --- Solve (contacts + distances)
          for (let it=0; it<K; it++){
            // refresh distances a bit (shock-prop)
            for (const e of this.edges){
              const A=this.p[e.i], B=this.p[e.j];
              const wi=A.invM, wj=B.invM; if (!(wi||wj)) continue;
              let dx=B.x-A.x, dy=B.y-A.y;
              const L=hypot(dx,dy)||1e-12;
              const nx=dx/L, ny=dy/L;
              const C=L - e.len; if (Math.abs(C)<1e-7) continue;
              const w=wi+wj;
              const alpha = this.alphaDist / (dtSub*dtSub + 1e-18);
              const dl = ( -C - alpha*e.lambda) / (w + alpha);
              e.lambda += dl;
              if (wi){ A.x -= dl*wi*nx; A.y -= dl*wi*ny; }
              if (wj){ B.x += dl*wj*nx; B.y += dl*wj*ny; }
            }

            for (const cc of contacts){
              const {cap, hit} = cc;
              const i = cap.e.i, j = cap.e.j;
              const A=this.p[i], B=this.p[j];
              const sParam = clamp(hit.s, 0, 1);

              const wi = A.invM*(1-sParam)*(1-sParam);
              const wj = B.invM*sParam*sParam;

              let wk = 0, dyn=null;
              if (cc.kind==='dcirc' && hit.dyn){ dyn = this.p[hit.dyn.pi]; wk = dyn.invM; }

              const w = wi + wj + wk;
              if (w===0) continue; // nothing to move

              // Normal projection (works for statics and dynamics)
              const nx=hit.nx, ny=hit.ny;
              const Cn = hit.pen;
              const alpha = this.alphaContact / (dtSub*dtSub + 1e-18);
              const dln = ( -Cn - alpha*cc.lambda ) / (w + alpha);
              cc.lambda += dln;

              if (A.invM){ A.x -= dln*wi*nx; A.y -= dln*wi*ny; }
              if (B.invM){ B.x += dln*wj*nx; B.y += dln*wj*ny; }
              if (wk)     { dyn.x += dln*wk*nx; dyn.y += dln*wk*ny; }

              // tangential friction along rope edge
              let tx = B.x - A.x, ty = B.y - A.y;
              const tL = hypot(tx,ty)||1e-12; tx/=tL; ty/=tL;
              const vAx = A.vx, vAy = A.vy;
              const vBx = B.vx, vBy = B.vy;
              const vKx = wk ? dyn.vx : 0, vKy = wk ? dyn.vy : 0;
              const vcx = (vBx*sParam + vAx*(1-sParam)) - vKx;
              const vcy = (vBy*sParam + vAy*(1-sParam)) - vKy;
              const vt = vcx*tx + vcy*ty;
              const jt = clamp(-vt, -this.mu*Math.abs(cc.lambda), this.mu*Math.abs(cc.lambda));
              if (A.invM){ A.x -= jt*wi*tx; A.y -= jt*wi*ty; }
              if (B.invM){ B.x += jt*wj*tx; B.y += jt*wj*ty; }
              if (wk)     { dyn.x += jt*wk*tx; dyn.y += jt*wk*ty; }
            }
          }

          // re-pin after solve
          if (pinIndex != null && pinIndex >= 0){
            const p = this.p[pinIndex];
            p.x = pinPos.x; p.y = pinPos.y;
          }
        }

        // ===== Ball (dynamic circle) vs statics =====
        for (const c of this.circles){
          const p = this.p[c.pi];
          // segment statics
          for (const s of this.staticSegs){
            const hit = this.circleVsSegment(p.x,p.y,c.r, s.x1,s.y1,s.x2,s.y2, s.r||0);
            if (hit){
              p.x += hit.nx * hit.pen;
              p.y += hit.ny * hit.pen;
              const vn = p.vx*hit.nx + p.vy*hit.ny;
              if (vn<0){ p.vx -= (1+this.rest)*vn*hit.nx; p.vy -= (1+this.rest)*vn*hit.ny; }
              // ground-ish friction
              const vt = p.vx*(-hit.ny) + p.vy*(hit.nx);
              const jtf = clamp(-vt, -this.mu*Math.abs(vn), this.mu*Math.abs(vn));
              p.vx += jtf*(-hit.ny); p.vy += jtf*(hit.nx);
            }
          }
          // circle statics
          for (const s of this.staticCircs){
            const hit = this.circleVsCircle(p.x,p.y,c.r, s.x,s.y,s.r);
            if (hit){
              p.x -= hit.nx * hit.pen;
              p.y -= hit.ny * hit.pen;
              const vn = p.vx*(-hit.nx) + p.vy*(-hit.ny);
              if (vn<0){ p.vx -= (1+this.rest)*vn*(-hit.nx); p.vy -= (1+this.rest)*vn*(-hit.ny); }
            }
          }
          // boxes (if any)
          for (const b of this.staticBoxes){
            const hit = this.circleVsAABB(p.x,p.y,c.r, b.x,b.y,b.w*0.5,b.h*0.5);
            if (hit){
              p.x += hit.nx * hit.pen;
              p.y += hit.ny * hit.pen;
              const vn = p.vx*hit.nx + p.vy*hit.ny;
              if (vn<0){ p.vx -= (1+this.rest)*vn*hit.nx; p.vy -= (1+this.rest)*vn*hit.ny; }
            }
          }
        }

        // ===== velocities from positional updates + air-damp
        for (let i=0;i<N;i++){
          const a=this.p[i];
          const invDt = 1/(dt||1e-9);
          const vx = (a.x - a.px) * invDt;
          const vy = (a.y - a.py) * invDt;
          a.vx = vx * this.air;
          a.vy = vy * this.air;
        }
      }
    }

    // ===== Yarn system (disk + wound path + rope) =====
    function buildWoundPath(total, segLen, R){
      const wX = new Array(total).fill(0), wY = new Array(total).fill(0);
      const inner = R - 2, outer = R;
      const locals=[];
      const pushFar = p => {
        if (!locals.length){ locals.push(p); return; }
        const q=locals[locals.length-1], d=hypot(p.x-q.x,p.y-q.y);
        if (d < segLen){
          const nx=(p.x-q.x)/(d||1), ny=(p.y-q.y)/(d||1);
          locals.push({x:q.x+nx*segLen, y:q.y+ny*segLen});
        } else locals.push(p);
      };
      pushFar({x: inner, y: inner});
      const layers = [
        {tilt:-.35, count:2, wR:.06, wT:.20},
        {tilt: .55, count:2, wR:.05, wT:.18},
        {tilt: 1.10, count:2, wR:.05, wT:.15}
      ];
      for (const L of layers){
        for (let k=0;k<L.count;k++){
          const phase=(k+.5)/L.count*PI*.7, ct=cos(L.tilt+phase), st=sin(L.tilt+phase);
          for (let a=-PI*.98; a<=PI*.98; a+=PI){
            const ca=cos(a), sa=sin(a);
            let x=inner*(ca*ct - sa*st), y=inner*(ca*st + sa*ct);
            const t=(a+PI)/(2*PI), inward=.25+.75*sin(t*PI), r=inner+2*L.wR*inward;
            const len=hypot(x,y)||1; x*=r/len; y*=r/len;
            const jitter=(sin((a+phase)*23.71)*.5+.5)*L.wT, ang=atan2(y,x)+jitter*.15;
            pushFar({x:r*cos(ang), y:r*sin(ang)});
          }
        }
      }
      while (locals.length < total){
        const a=random()*PI*2, rr=outer+(inner-outer)*random();
        pushFar({x: rr*cos(a), y: rr*sin(a)});
      }
      for (let i=0;i<total;i++){ const p=locals[i]||locals[locals.length-1]; wX[i]=p.x; wY[i]=p.y; }
      return {wX, wY};
    }

    // ===== Scene build =====
    const TOTAL = 1000;
    const pxPerM = 30;
    const LEN_M = 100;
    const SEG = (LEN_M * pxPerM) / (TOTAL - 1);
    const RADIUS = 38;
    const ROPE_R = 2;
    const XP = {
      g: 1600, air: 0.997, rest: 0.55, wall: 0.5, mu: 0.4,
      alphaDist: 1e-7, alphaContact: 1e-7,
      cfl: 0.3, maxSub: 12, iters: 10, capsuleRadius: ROPE_R
    };

    sim = new XPBDSim(XP);

    // Dynamic disk (yarn ball)
    const ball = sim.addCircle(0,0, RADIUS, 1);
    // Rope nodes
    const ropeIdx = [];
    for (let i=0;i<TOTAL;i++){ ropeIdx.push(sim.addParticle(0,0, 1)); }
    for (let i=0;i<TOTAL-1;i++){ sim.addEdge(ropeIdx[i], ropeIdx[i+1], SEG); }

    // Statics
    platform = {x1:0,y1:0,x2:0,y2:0, r:15};
    peg = {x:0,y:0, r:24};
    sim.addStaticSegment(0,0,0,0, platform.r);
    sim.addStaticCircle(0,0, peg.r);

    // Wound path
    const wound = buildWoundPath(TOTAL, SEG, RADIUS);
    let freeCount = 0;

    function worldAnchor(i, cx,cy, ang){
      const ca=cos(ang), sa=sin(ang);
      const wx = cx + (wound.wX[i]*ca - wound.wY[i]*sa);
      const wy = cy + (wound.wX[i]*sa + wound.wY[i]*ca);
      return {x:wx, y:wy};
    }

    function layoutInitial(){
      resize();
      const cx = world.w*0.5, cy = world.h*0.25;
      const bi = ball.pi;
      sim.p[bi].x = cx; sim.p[bi].y = cy;
      sim.p[bi].px = cx; sim.p[bi].py = cy;
      sim.p[bi].vx = 0; sim.p[bi].vy = 0;

      for (let i=0;i<TOTAL;i++){
        const a = worldAnchor(i, cx, cy, 0);
        const p = sim.p[ropeIdx[i]];
        p.x=a.x; p.y=a.y; p.px=a.x; p.py=a.y; p.vx=0; p.vy=0;
      }
      freeCount = 0;
    }
    layoutInitial();

    function freeSegments(n=1){
      const cx = sim.p[ball.pi].x, cy = sim.p[ball.pi].y;
      for (let k=0;k<n && freeCount<TOTAL; k++){
        const i = freeCount;
        const a = worldAnchor(i, cx, cy, 0);
        const p = sim.p[ropeIdx[i]];
        const bx = sim.p[ball.pi].vx, by = sim.p[ball.pi].vy;
        p.x=a.x; p.y=a.y; p.vx = bx; p.vy = by;
        freeCount++;
      }
    }

    // ==== Input ====
    const mouse={x:0,y:0, down:false, t:performance.now()};
    function setMouse(e,down=null){
      const r=C.getBoundingClientRect();
      mouse.x=e.clientX - r.left; mouse.y=e.clientY - r.top;
      if (down!=null) mouse.down=down;
      mouse.t = performance.now();
    }
    C.addEventListener('pointermove', e=>setMouse(e));
    C.addEventListener('pointerdown', e=>{
      setMouse(e,true);
      const b = sim.p[ball.pi];
      let dx=mouse.x-b.x, dy=mouse.y-b.y;
      const d=hypot(dx,dy)||1; dx/=d; dy/=d;
      dy = Math.min(dy, -Math.SQRT1_2);
      b.vx += dx * 10; b.vy += dy * 10;
      freeSegments(12);
    });
    C.addEventListener('pointerup', ()=>{ mouse.down=false; });

    // ==== Render helpers ====
    function drawWoundPath(X, cx,cy){
      if (freeCount >= TOTAL-1) return;
      X.save();
      X.translate(cx,cy);
      X.lineCap='round'; X.lineJoin='round'; X.strokeStyle='#d43375'; X.lineWidth=3;

      X.beginPath();
      let i0 = freeCount;
      let xi=wound.wX[i0], yi=wound.wY[i0];
      X.moveTo(xi, yi);
      X.quadraticCurveTo(xi, yi, midpoint(xi, wound.wX[i0+1]||xi), midpoint(yi, wound.wY[i0+1]||yi));
      for (let i=i0+1; i<=TOTAL-2; i++){
        X.moveTo(midpoint(wound.wX[i-1], wound.wX[i]), midpoint(wound.wY[i-1], wound.wY[i]));
        X.quadraticCurveTo(wound.wX[i], wound.wY[i], midpoint(wound.wX[i], wound.wX[i+1]), midpoint(wound.wY[i], wound.wY[i+1]));
      }
      X.stroke();
      X.restore();
    }
    function drawTail(X){
      const nFree = Math.min(freeCount, TOTAL);
      if (nFree<=1) return;
      X.lineCap='round'; X.lineJoin='round'; X.strokeStyle='#d43375'; X.lineWidth=3;

      const mX=new Array(nFree-1), mY=new Array(nFree-1);
      for (let i=0;i<nFree-1;i++){
        const A=sim.p[ropeIdx[i]], B=sim.p[ropeIdx[i+1]];
        mX[i]=midpoint(A.x,B.x); mY[i]=midpoint(A.y,B.y);
      }

      X.beginPath();
      const P0=sim.p[ropeIdx[0]];
      X.moveTo(P0.x,P0.y);
      X.quadraticCurveTo(P0.x,P0.y, mX[0],mY[0]);
      for (let i=1;i<nFree-1;i++){
        const Pi=sim.p[ropeIdx[i]];
        X.quadraticCurveTo(Pi.x,Pi.y, mX[i],mY[i]);
      }

      if (nFree < TOTAL){
        const bA = worldAnchor(freeCount, sim.p[ball.pi].x, sim.p[ball.pi].y, 0);
        const Pn_1=sim.p[ropeIdx[nFree-1]];
        X.quadraticCurveTo(sim.p[ropeIdx[nFree]].x, sim.p[ropeIdx[nFree]].y, midpoint(Pn_1.x, bA.x), midpoint(Pn_1.y, bA.y));
        X.quadraticCurveTo(bA.x,bA.y, bA.x,bA.y);
      }
      X.stroke();
    }

    // ==== Main loop ====
    let pStep = performance.now();
    function step(now){
      const dt = clamp((now - pStep)/1000, 0, 1/60);
      pStep = now;

      const cx = sim.p[ball.pi].x, cy = sim.p[ball.pi].y;
      const pinIndex = (freeCount<=TOTAL-1) ? ropeIdx[freeCount] : null;
      const pinPos = (freeCount<=TOTAL-1) ? worldAnchor(freeCount, cx, cy, 0) : null;

      const ropeRange = [0, Math.max(0, freeCount)];
      sim.step(dt, ropeRange, ROPE_R, pinIndex, pinPos||{x:0,y:0});

      const freedLength = (SEG * freeCount * ((TOTAL-1)/TOTAL) / pxPerM);

      // Render
      X.fillStyle='#222'; X.fillRect(0,0,world.w,world.h);

      X.strokeStyle='#444'; X.lineWidth=50;
      X.beginPath(); X.moveTo(0, world.h-1); X.lineTo(world.w, world.h-1); X.stroke();

      X.strokeStyle='#666'; X.lineWidth=platform.r; X.lineCap='round';
      X.beginPath(); X.moveTo(platform.x1, platform.y1); X.lineTo(platform.x2, platform.y2); X.stroke();

      X.fillStyle='#666'; X.beginPath(); X.arc(peg.x, peg.y, peg.r, 0, Math.PI*2); X.fill();

      drawWoundPath(X, sim.p[ball.pi].x, sim.p[ball.pi].y);
      drawTail(X);

      X.fillStyle='#fff';
      X.font='14px system-ui,sans-serif';
      X.fillText('yarn: ' + freedLength.toFixed(1) + ' m', 12, 22);

      requestAnimationFrame(step);
    }

    // Build & start
    resize();
    requestAnimationFrame(step);
  });
</script>
