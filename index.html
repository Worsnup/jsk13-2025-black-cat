<script>
document.addEventListener('DOMContentLoaded', () => {
  // === Canvas bootstrap ===
  const $ = document, W = window, B = $.body, C = $.createElement('canvas'), X = C.getContext('2d');
  (document.getElementById('content') || B).innerHTML = '';
  Object.assign(B.style, {margin: '0', overflow: 'hidden'});
  Object.assign(C.style, {display: 'block', touchAction: 'none'});
  B.appendChild(C);

  // === Shorthand math ===
  const {max, min, cos, sin, PI, hypot, random, atan2} = Math;

  // === World / DPI ===
  const DPR = min(2, W.devicePixelRatio || 1), world = {w: 0, h: 0};
  const resize = () => {
    const w = W.innerWidth || $.documentElement.clientWidth, h = W.innerHeight || $.documentElement.clientHeight;
    Object.assign(C.style, {width: w + 'px', height: h + 'px'});
    C.width = (w * DPR) | 0;
    C.height = (h * DPR) | 0;
    X.setTransform(DPR, 0, 0, DPR, 0, 0);
    world.w = C.clientWidth;
    world.h = C.clientHeight;
  };
  W.addEventListener('resize', resize);
  resize();

  // === Tunables ===
  const GRAV = 1600, REST = .55, GFRIC = .015, AIR = .997, WALL = .5;
  const R = 38, LEN = 60, TOTAL = 300, ITERS = 5, SUB_STEPS = 2, pxPerM = 120, SEG = (LEN * pxPerM) / (TOTAL - 1);

  // === Disk ===
  const ball = {
    x: world.w * .5, y: world.h * .25, px: world.w * .5 - 120 * (1 / 60), py: world.h * .25, angle: 0, grounded: false, live: true
  };

  // === Rope ===
  const P = Array(TOTAL).fill(0).map(() => ({x: 0, y: 0, px: 0, py: 0}));
  const woundLocal = Array(TOTAL).fill(0).map(() => ({x: 0, y: 0}));
  let freeCount = 1;

  const toWorld = (lx, ly, ca, sa, cx, cy) => ({x: cx + (lx * ca - ly * sa), y: cy + (lx * sa + ly * ca)});
  const clamp = (v, a, b) => max(a, min(b, v));

  // Build interior anchors for the wound portion
  function buildWoundPath() {
    const inner = R - 2, outer = R, locals = [];
    const layers = [{tilt: -.35, count: 2, wR: .06, wT: .20}, {tilt: .55, count: 2, wR: .05, wT: .18}, {
      tilt: 1.10, count: 2, wR: .05, wT: .15
    }];
    const pushFar = p => {
      const q = locals[locals.length - 1];
      if (!q || hypot(p.x - q.x, p.y - q.y) >= SEG) locals.push(p);
    };
    pushFar({x: inner, y: inner});
    for (const L of layers) {
      for (let k = 0; k < L.count; k++) {
        const phase = (k + .5) / L.count * PI * .7, ct = cos(L.tilt + phase), st = sin(L.tilt + phase);
        for (let a = -PI * .98; a <= PI * .98; a += PI) {
          const ca = cos(a), sa = sin(a);
          let x = inner * (ca * ct - sa * st), y = inner * (ca * st + sa * ct);
          const t = (a + PI) / (2 * PI), inward = .25 + .75 * sin(t * PI), r = inner + 2 * L.wR * inward;
          const len = hypot(x, y) || 1;
          x *= r / len;
          y *= r / len;
          const jitter = (sin((a + phase) * 23.71) * .5 + .5) * L.wT, ang = atan2(y, x) + jitter * .15;
          pushFar({x: r * cos(ang), y: r * sin(ang)});
        }
      }
    }
    while (locals.length < TOTAL) {
      const a = random() * PI * 2, rr = outer + (inner - outer) * random();
      pushFar({x: rr * cos(a), y: rr * sin(a)});
    }
    for (let i = 0; i < TOTAL; i++) {
      const p = locals[i] || locals[locals.length - 1];
      woundLocal[i].x = p.x;
      woundLocal[i].y = p.y;
    }
  }

  function glueWound() {
    const ca = cos(ball.angle), sa = sin(ball.angle), cx = ball.x, cy = ball.y;
    for (let i = freeCount; i < TOTAL; i++) {
      const L = woundLocal[i], w = toWorld(L.x, L.y, ca, sa, cx, cy);
      P[i].px = P[i].x = w.x;
      P[i].py = P[i].y = w.y;
    }
  }

  function initRope() {
    buildWoundPath();
    glueWound();
    // short dangling tail (kept same simplistic diag seed)
    const head = P[freeCount], p1x = head.x + SEG, p1y = head.y + SEG + 2, p0x = p1x + SEG, p0y = p1y + SEG + 2;
    Object.assign(P[freeCount - 1], {x: p1x, y: p1y, px: p1x, py: p1y});
    Object.assign(P[0], {x: p0x, y: p0y, px: p0x, py: p0y});
  }

  initRope();

  // === Input ===
  const mouse = {x: 0, y: 0, down: false, t: performance.now()};
  let pMouse = {x: 0, y: 0, t: performance.now() - 0.01}, timer = 0;
  const setMouse = e => {
    pMouse = {x: mouse.x, y: mouse.y, t: mouse.t};
    const r = C.getBoundingClientRect();
    mouse.x = e.clientX - r.left;
    mouse.y = e.clientY - r.top;
    mouse.t = performance.now();
  };
  C.addEventListener('pointermove', setMouse);
  C.addEventListener('pointerdown', e => {
    mouse.down = true;
    setMouse(e);
  });
  C.addEventListener('pointerup', () => mouse.down = false);

  // === Physics ===
  function integrateDisk(dt) {
    if (!ball.live) {
      ball.x = ball.y = ball.px = ball.py = -999;
      ball.angle = 0;
      ball.grounded = false;
      return;
    }
    const vx = ball.x - ball.px, vy = ball.y - ball.py;
    ball.px = ball.x;
    ball.py = ball.y;
    ball.x += vx * AIR;
    ball.y += vy * AIR + GRAV * dt * dt;

    const {w, h} = world;
    ball.grounded = false;

    if (ball.y + R > h) {
      ball.y = h - R;
      const vpy = ball.py - ball.y;
      ball.py = ball.y + vpy * -REST;
      ball.grounded = true;
    } else if (ball.y - R < 0) {
      ball.y = R;
      const vpy = ball.py - ball.y;
      ball.py = ball.y + vpy * -WALL;
    }

    if (ball.x - R < 0) {
      ball.x = R;
      const vpx = ball.px - ball.x;
      ball.px = ball.x + vpx * -WALL;
    } else if (ball.x + R > w) {
      ball.x = w - R;
      const vpx = ball.px - ball.x;
      ball.px = ball.x + vpx * -WALL;
    }

    if (ball.grounded) {
      const dx = ball.x - ball.px;
      ball.angle += dx / R;
      ball.px = ball.x - (ball.x - ball.px) * (1 - GFRIC);
    }
  }

  function integrateTail(dt) {
    const {w, h} = world, g = GRAV * dt * dt;
    for (let i = 0; i < freeCount; i++) {
      const p = P[i], vx = p.x - p.px, vy = p.y - p.py;
      p.px = p.x;
      p.py = p.y;
      p.x += vx;
      p.y += vy + g;
      if (p.y > h) {
        p.y = h;
        p.py = p.y + (p.y - p.py) * -REST;
        p.px = p.x - (p.x - p.px) * (1 - GFRIC);
      } else if (p.y < 0) {
        p.y = 0;
        p.py = p.y + (p.y - p.py) * -WALL;
      }
      if (p.x < 0) {
        p.x = 0;
        p.px = p.x + (p.x - p.px) * -WALL;
      } else if (p.x > w) {
        p.x = w;
        p.px = p.x + (p.x - p.px) * -WALL;
      }
    }
  }

  function satisfy() {
    for (let k = 0; k < ITERS; k++) {
      for (let i = 1; i < TOTAL; i++) {
        const a = P[i - 1], b = P[i];
        let dx = b.x - a.x, dy = b.y - a.y, d = hypot(dx, dy) || 1e-6, diff = (d - SEG) / d;
        let ma = .5, mb = .5;
        if (i >= freeCount && i - 1 >= freeCount) {
          ma = mb = 0;
        } else if (i >= freeCount) {
          ma = 1;
          mb = 0;
        } else if (i - 1 >= freeCount) {
          ma = 0;
          mb = 1;
        }
        a.x += dx * diff * ma;
        a.y += dy * diff * ma;
        b.x -= dx * diff * mb;
        b.y -= dy * diff * mb;
        if (i - 1 < freeCount && a.y > world.h) a.y = world.h;
        if (i < freeCount && b.y > world.h) b.y = world.h;
      }
    }
  }

  const freeSegments = (n = 1) => {
    for (let k = 0; k < (n | 0) && freeCount < TOTAL; k++ & freeCount++) ball.live = freeCount < TOTAL;
  }

  function mouseImpulse(now) {
    timer = max(0, timer - (now - pMouse.t) / 1000);
    const mdt = 1e-3 * max(1, now - pMouse.t), mvx = (mouse.x - pMouse.x) / mdt, mvy = (mouse.y - pMouse.y) / mdt;
    let dx = mouse.x - ball.x, dy = mouse.y - ball.y, d = hypot(dx, dy);
    if (timer > 0 || d > R) return;
    const base = clamp(-(dx * mvx + dy * mvy), -250, 250) / d, Jx = -dx * base, Jy = -dy * base - 150,
      vx = (ball.x - ball.px) + Jx * (1 / 60), vy = (ball.y - ball.py) + Jy * (1 / 60);
    ball.px = ball.x - vx;
    ball.py = ball.y - vy;
    console.log(base, Jx, Jy, vx, vy);
    freeSegments(hypot(Jx, Jy) / 150);
    timer = .1;
  }

  // === Render ===
  function drawYarn() {
    const n = P.length, mid = (a, b) => ({x: (a.x + b.x) * .5, y: (a.y + b.y) * .5});
    const PAL = [{a: .42, w: 3, col: '#f9a9c8'}, {a: .32, w: 3, col: '#8a2b4f'}, {a: .22, w: 3, col: '#6b1f3d'}];
    X.lineCap = 'round';
    X.lineJoin = 'round';
    for (const L of PAL) {
      X.strokeStyle = L.col;
      X.globalAlpha = L.a;
      X.lineWidth = L.w;
      X.beginPath();
      let m01 = mid(P[0], P[1]);
      X.moveTo(P[0].x, P[0].y);
      X.quadraticCurveTo(P[0].x, P[0].y, m01.x, m01.y);
      X.stroke();
      for (let i = 1; i <= n - 2; i++) {
        const mPrev = mid(P[i - 1], P[i]), mNext = mid(P[i], P[i + 1]);
        X.beginPath();
        X.moveTo(mPrev.x, mPrev.y);
        X.quadraticCurveTo(P[i].x, P[i].y, mNext.x, mNext.y);
        X.stroke();
      }
    }
    X.globalAlpha = 1;
  }

  // === Main loop ===
  let pStep = performance.now();
  function step(now) {
    const dt = clamp((now - pStep) / 1000, 0, 0.033), h = dt / SUB_STEPS;
    pStep = now;
    for (let s = 0; s < SUB_STEPS; s++) {
      integrateDisk(h);
      glueWound();
      integrateTail(h);
      satisfy();
      mouseImpulse(now);
    }
    X.fillStyle = '#222';
    X.fillRect(0, 0, world.w, world.h); // clear + bg in one
    X.strokeStyle = 'rgba(255,255,255,.08)';
    X.lineWidth = 2;
    X.beginPath();
    X.moveTo(0, world.h - 1);
    X.lineTo(world.w, world.h - 1);
    X.stroke();
    drawYarn();
    X.fillStyle = 'rgba(255,255,255,.9)';
    X.font = '14px system-ui,sans-serif';
    X.fillText('yarn: ' + ((SEG * (freeCount - 1) / pxPerM).toFixed(1)) + ' m', 12, 22);
    requestAnimationFrame(step);
  }

  requestAnimationFrame(step);
});
</script>