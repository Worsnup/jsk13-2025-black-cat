<script>
document.addEventListener('DOMContentLoaded', () => {
  // === Canvas bootstrap ===
  const $ = document, W = window, B = $.body, C = $.createElement('canvas'), X = C.getContext('2d');
  (document.getElementById('content') || B).innerHTML = '';
  Object.assign(B.style, {margin: '0', overflow: 'hidden'});
  Object.assign(C.style, {display: 'block', touchAction: 'none'});
  B.appendChild(C);

  // === Shorthand math ===
  const {max, min, cos, sin, PI, hypot, random, atan2} = Math;

  // === World / DPI ===
  const DPR = min(2, W.devicePixelRatio || 1), world = {w: 0, h: 0};
  const resize = () => {
    const w = W.innerWidth || $.documentElement.clientWidth, h = W.innerHeight || $.documentElement.clientHeight;
    Object.assign(C.style, {width: w + 'px', height: h + 'px'});
    C.width = (w * DPR) | 0;
    C.height = (h * DPR) | 0;
    X.setTransform(DPR, 0, 0, DPR, 0, 0);
    world.w = C.clientWidth;
    world.h = C.clientHeight;
  };
  W.addEventListener('resize', resize);
  resize();

  // === Tunables ===
  const GRAV = 1600, REST = .55, GFRIC = .015, AIR = .997, WALL = .5;
  const R = 38, LEN = 60, TOTAL = 300, ITERS = 5, SUB_STEPS = 2, pxPerM = 120, SEG = (LEN * pxPerM) / (TOTAL - 1);

  // === Disk ===
  const ball = {
    x: world.w * .5, y: world.h * .25, px: world.w * .5 - 120 * (1 / 60), py: world.h * .25, angle: 0, grounded: false, live: true
  };

  // === Rope ===
  const rX = Array(TOTAL).fill(0).map(() => 0);
  const rY = Array(TOTAL).fill(0).map(() => 0);
  const vX = Array(TOTAL).fill(0).map(() => 0);
  const vY = Array(TOTAL).fill(0).map(() => 0);
  const wX = Array(TOTAL).fill(0).map(() => 0);
  const wY = Array(TOTAL).fill(0).map(() => 0);
  let freeCount = 0;

  const clamp = (v, a, b) => max(a, min(b, v));
  const midpoint = (a, b) => .5 * (a + b);

  // Build interior anchors for the wound portion
  function initWoundPath() {
    const inner = R - 2, outer = R, locals = [];
    const layers = [{tilt: -.35, count: 2, wR: .06, wT: .20}, {tilt: .55, count: 2, wR: .05, wT: .18}, {
      tilt: 1.10, count: 2, wR: .05, wT: .15
    }];
    const pushFar = p => {
      if (locals.length === 0) {
        locals.push(p);
        return;
      }
      const q = locals[locals.length - 1], d = hypot(p.x - q.x, p.y - q.y);
      if (!q || d < SEG) {
        const nx = (p.x - q.x) / d, ny = (p.y - q.y) / d;
        locals.push({x: q.x + nx * SEG, y: q.y + ny * SEG});
      } else {
        locals.push(p);
      }
    };
    pushFar({x: inner, y: inner});
    for (const L of layers) {
      for (let k = 0; k < L.count; k++) {
        const phase = (k + .5) / L.count * PI * .7, ct = cos(L.tilt + phase), st = sin(L.tilt + phase);
        for (let a = -PI * .98; a <= PI * .98; a += PI) {
          const ca = cos(a), sa = sin(a);
          let x = inner * (ca * ct - sa * st), y = inner * (ca * st + sa * ct);
          const t = (a + PI) / (2 * PI), inward = .25 + .75 * sin(t * PI), r = inner + 2 * L.wR * inward;
          const len = hypot(x, y) || 1;
          x *= r / len;
          y *= r / len;
          const jitter = (sin((a + phase) * 23.71) * .5 + .5) * L.wT, ang = atan2(y, x) + jitter * .15;
          pushFar({x: r * cos(ang), y: r * sin(ang)});
        }
      }
    }
    while (locals.length < TOTAL) {
      const a = random() * PI * 2, rr = outer + (inner - outer) * random();
      pushFar({x: rr * cos(a), y: rr * sin(a)});
    }
    for (let i = 0; i < TOTAL; i++) {
      const p = locals[i] || locals[locals.length - 1];
      wX[i] = p.x;
      wY[i] = p.y;
    }
  }

  let woundPath = null;
  function rebuildWoundPath() {
    if (TOTAL - freeCount <= 0) {
      woundPath = null;
      return;
    }
    const path = new Path2D();
    const xi = wX[freeCount], yi = wY[freeCount];
    path.moveTo(xi, yi);
    path.quadraticCurveTo(xi, yi, midpoint(xi, wX[freeCount + 1] || xi), midpoint(yi, wY[freeCount + 1] || yi));
    for (let i = freeCount + 1; i <= TOTAL - 2; i++) {
      path.moveTo(midpoint(wX[i - 1], wX[i]), midpoint(wY[i - 1], wY[i]));
      path.quadraticCurveTo(wX[i], wY[i], midpoint(wX[i], wX[i + 1]), midpoint(wY[i], wY[i + 1]));
    }
    woundPath = path;
  }

  function glue(i, x, y) {
    rX[i] = x;  rY[i] = y; vX[i] = 0; vY[i] = 0;
  }

  function updateAnchor() {
    if (freeCount > TOTAL - 1) return;
    const wx = ball.x + (wX[freeCount] * cos(ball.angle) - wY[freeCount] * sin(ball.angle)),
      wy = ball.y + (wX[freeCount] * sin(ball.angle) + wY[freeCount] * cos(ball.angle));
    glue(freeCount, wx, wy);
  }

  function initRope() {
    initWoundPath();
    rebuildWoundPath();
    updateAnchor();
  }

  initRope();

  // === Input ===
  const mouse = {x: 0, y: 0, down: false, t: performance.now()};
  let pMouse = {x: 0, y: 0, t: performance.now() - 0.01}, timer = 0;
  const setMouse = e => {
    pMouse = {x: mouse.x, y: mouse.y, t: mouse.t};
    const r = C.getBoundingClientRect();
    mouse.x = e.clientX - r.left;
    mouse.y = e.clientY - r.top;
    mouse.t = performance.now();
  };
  C.addEventListener('pointermove', setMouse);
  C.addEventListener('pointerdown', e => {
    mouse.down = true;
    setMouse(e);
  });
  C.addEventListener('pointerup', () => mouse.down = false);

  // === Physics ===
  function integrateDisk(dt) {
    if (!ball.live) {
      ball.x = ball.y = ball.px = ball.py = -999;
      ball.angle = 0;
      ball.grounded = false;
      return;
    }
    const vx = ball.x - ball.px, vy = ball.y - ball.py;
    ball.px = ball.x;
    ball.py = ball.y;
    ball.x += vx * AIR;
    ball.y += vy * AIR + GRAV * dt * dt;

    const {w, h} = world;
    ball.grounded = false;

    if (ball.y + R > h) {
      ball.y = h - R;
      const vpy = ball.py - ball.y;
      ball.py = ball.y + vpy * -REST;
      ball.grounded = true;
    } else if (ball.y - R < 0) {
      ball.y = R;
      const vpy = ball.py - ball.y;
      ball.py = ball.y + vpy * -WALL;
    }

    if (ball.x - R < 0) {
      ball.x = R;
      const vpx = ball.px - ball.x;
      ball.px = ball.x + vpx * -WALL;
    } else if (ball.x + R > w) {
      ball.x = w - R;
      const vpx = ball.px - ball.x;
      ball.px = ball.x + vpx * -WALL;
    }

    if (ball.grounded) {
      const dx = ball.x - ball.px;
      ball.angle += dx / R;
      ball.px = ball.x - (ball.x - ball.px) * (1 - GFRIC);
    }
  }

  function integrateTail(dt) {
    const {w, h} = world, g = GRAV * dt * dt;
    for (let i = 0; i < freeCount; i++) {
      rX[i] += vX[i];
      rY[i] += vY[i] += g;
      if (rY[i] > h) {
        rY[i] = h;
        vY[i] *= -REST;
        vX[i] *= GFRIC - 1;
      } else if (rY[i] < 0) {
        rY[i] = 0;
        vY[i] *= -WALL;
      }
      if (rX[i] < 0) {
        rX[i] = 0;
        vX[i] *= -WALL;
      } else if (rX[i] > w) {
        rX[i] = w;
        vX[i] *= -WALL;
      }
    }
  }

  function satisfy() {
    for (let k = 0; k < ITERS; k++) {
      for (let i = 1; i <= Math.min(TOTAL - 1, freeCount); i++) {
        let dx = rX[i] - rX[i - 1], dy = rY[i] - rY[i - 1], d = hypot(dx, dy) || 1e-6, diff = (d - SEG) / d;
        let ma = .5, mb = .5;
        if (i >= freeCount && i - 1 >= freeCount) {
          ma = mb = 0;
        } else if (i >= freeCount) {
          ma = 1;
          mb = 0;
        } else if (i - 1 >= freeCount) {
          ma = 0;
          mb = 1;
        }
        rX[i - 1] += dx * diff * ma;
        rY[i - 1] += dy * diff * ma;
        rX[i] -= dx * diff * mb;
        rY[i] -= dy * diff * mb;
        if (i - 1 < freeCount && rY[i - 1] > world.h) rY[i - 1] = world.h;
        if (i < freeCount && rY[i] > world.h) rY[i] = world.h;
      }
    }
  }

  const freeSegments = (n = 1) => {
    const oldCount = freeCount;
    for (let k = 0; k < (n | 0) && freeCount < TOTAL; k++ & freeCount++) ball.live = freeCount < TOTAL;
    if (freeCount !== oldCount) rebuildWoundPath();
  }

  function mouseImpulse(now) {
    timer = max(0, timer - (now - pMouse.t) / 1000);
    const mdt = 1e-3 * max(1, now - pMouse.t), mvx = (mouse.x - pMouse.x) / mdt, mvy = (mouse.y - pMouse.y) / mdt;
    let dx = mouse.x - ball.x, dy = mouse.y - ball.y, d = hypot(dx, dy);
    if (timer > 0 || d > R) return;
    const base = clamp(-(dx * mvx + dy * mvy), -250, 250) / d, Jx = -dx * base, Jy = -dy * base - 150,
      vx = (ball.x - ball.px) + Jx * (1 / 60), vy = (ball.y - ball.py) + Jy * (1 / 60);
    ball.px = ball.x - vx;
    ball.py = ball.y - vy;
    // console.log(base, Jx, Jy, vx, vy);
    freeSegments(hypot(Jx, Jy) / 150);
    timer = .1;
  }

  // === Render ===
  function drawYarn() {
    X.lineCap = 'round';
    X.lineJoin = 'round';

    if (woundPath) {
      X.save();
      X.translate(ball.x, ball.y);
      X.rotate(ball.angle);
      X.strokeStyle = '#d43375';
      X.globalAlpha = 0.5;
      X.lineWidth = 3;
      X.stroke(woundPath);
      X.restore();
    }

    const nFree = min(freeCount, TOTAL);
    if (nFree > 0) {
      const mX = new Array(nFree - 1), mY = new Array(nFree - 1);
      for (let i = 0; i < nFree - 1; i++) {
        mX[i] = midpoint(rX[i], rX[i + 1]);
        mY[i] = midpoint(rY[i], rY[i + 1]);
      }

      X.strokeStyle = '#d43375';
      X.globalAlpha = 0.5;
      X.lineWidth = 3;
      X.beginPath();
      X.moveTo(rX[0], rY[0]);
      // head segment
      X.quadraticCurveTo(rX[0], rY[0], mX[0], mY[0]);
      // remaining
      for (let i = 1; i < nFree; i++) {
        X.moveTo(mX[i - 1], mY[i - 1]);
        X.quadraticCurveTo(rX[i], rY[i], mX[i], mY[i]);
      }
      if (nFree < TOTAL) {
        const ca = cos(ball.angle), sa = sin(ball.angle);
        X.moveTo(mX[nFree - 1], mY[nFree - 1]);
        X.quadraticCurveTo(rX[nFree - 1], rY[nFree - 1], ball.x + (wX[freeCount + 1] * ca - wY[freeCount + 1] * sa), ball.y + (wX[freeCount + 1] * sa + wY[freeCount + 1] * ca));
      }
      X.stroke();
    }

    X.globalAlpha = 1;
  }

  // === Main loop ===
  let pStep = performance.now();
  function step(now) {
    const dt = clamp((now - pStep) / 1000, 0, 0.033), h = dt / SUB_STEPS;
    pStep = now;
    for (let s = 0; s < SUB_STEPS; s++) {
      mouseImpulse(now);
      integrateDisk(h)
      updateAnchor();
      integrateTail(h);
      satisfy();
    }
    X.fillStyle = '#222';
    X.fillRect(0, 0, world.w, world.h); // clear + bg in one
    X.strokeStyle = 'rgba(255,255,255,.08)';
    X.lineWidth = 2;
    X.beginPath();
    X.moveTo(0, world.h - 1);
    X.lineTo(world.w, world.h - 1);
    X.stroke();
    drawYarn();
    X.fillStyle = 'rgba(255,255,255,.9)';
    X.font = '14px system-ui,sans-serif';
    X.fillText('yarn: ' + ((SEG * (freeCount - 1) / pxPerM).toFixed(1)) + ' m', 12, 22);
    requestAnimationFrame(step);
  }

  requestAnimationFrame(step);
});
</script>