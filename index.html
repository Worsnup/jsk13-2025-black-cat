<script>
document.addEventListener('DOMContentLoaded', () => {
  // === Canvas bootstrap ===
  const $ = document, W = window, B = $.body, C = $.createElement('canvas'), X = C.getContext('2d');
  (document.getElementById('content') || B).innerHTML = '';
  Object.assign(B.style, {margin: '0', overflow: 'hidden'});
  Object.assign(C.style, {display: 'block', touchAction: 'none'});
  B.appendChild(C);

  // === Shorthand math ===
  const {max, min, cos, sin, PI, hypot, random, atan2, sqrt} = Math;

  // === World / DPI ===
  const DPR = min(2, W.devicePixelRatio || 1), world = {w: 0, h: 0};
  const resize = () => {
    const w = W.innerWidth || $.documentElement.clientWidth, h = W.innerHeight || $.documentElement.clientHeight;
    Object.assign(C.style, {width: w + 'px', height: h + 'px'});
    C.width = (w * DPR) | 0;
    C.height = (h * DPR) | 0;
    X.setTransform(DPR, 0, 0, DPR, 0, 0);
    world.w = C.clientWidth;
    world.h = C.clientHeight;
  };
  W.addEventListener('resize', resize);
  resize();

  // === Tunables ===
  const GRAV = 1600, REST = .55, GFRIC = .015, AIR = .997, WALL = .5;
  const R = 38, LEN = 100, TOTAL = 1000, ITERS = 10, pxPerM = 120, SEG = (LEN * pxPerM) / (TOTAL - 1);
  // === Disk ===
  const ball = {
    x: world.w * .5, y: world.h * .25, vX: 0, vY: 0, angle: 0, omega: 0, grounded: false, live: true
  };

  // === Rope ===
  const rX = Array(TOTAL).fill(0).map(() => 0);
  const rY = Array(TOTAL).fill(0).map(() => 0);
  const vX = Array(TOTAL).fill(0).map(() => 0);
  const vY = Array(TOTAL).fill(0).map(() => 0);
  const wX = Array(TOTAL).fill(0).map(() => 0);
  const wY = Array(TOTAL).fill(0).map(() => 0);
  let freeCount = 0;
  let freedLength = 0;

  const clamp = (v, a, b) => max(a, min(b, v));
  const midpoint = (a, b) => .5 * (a + b);

  // Build interior anchors for the wound portion
  function initWoundPath() {
    const inner = R - 2, outer = R, locals = [];
    const layers = [{tilt: -.35, count: 2, wR: .06, wT: .20}, {tilt: .55, count: 2, wR: .05, wT: .18}, {
      tilt: 1.10, count: 2, wR: .05, wT: .15
    }];
    const pushFar = p => {
      if (locals.length === 0) {
        locals.push(p);
        return;
      }
      const q = locals[locals.length - 1], d = hypot(p.x - q.x, p.y - q.y);
      if (!q || d < SEG) {
        const nx = (p.x - q.x) / d, ny = (p.y - q.y) / d;
        locals.push({x: q.x + nx * SEG, y: q.y + ny * SEG});
      } else {
        locals.push(p);
      }
    };
    pushFar({x: inner, y: inner});
    for (const L of layers) {
      for (let k = 0; k < L.count; k++) {
        const phase = (k + .5) / L.count * PI * .7, ct = cos(L.tilt + phase), st = sin(L.tilt + phase);
        for (let a = -PI * .98; a <= PI * .98; a += PI) {
          const ca = cos(a), sa = sin(a);
          let x = inner * (ca * ct - sa * st), y = inner * (ca * st + sa * ct);
          const t = (a + PI) / (2 * PI), inward = .25 + .75 * sin(t * PI), r = inner + 2 * L.wR * inward;
          const len = hypot(x, y) || 1;
          x *= r / len;
          y *= r / len;
          const jitter = (sin((a + phase) * 23.71) * .5 + .5) * L.wT, ang = atan2(y, x) + jitter * .15;
          pushFar({x: r * cos(ang), y: r * sin(ang)});
        }
      }
    }
    while (locals.length < TOTAL) {
      const a = random() * PI * 2, rr = outer + (inner - outer) * random();
      pushFar({x: rr * cos(a), y: rr * sin(a)});
    }
    for (let i = 0; i < TOTAL; i++) {
      const p = locals[i] || locals[locals.length - 1];
      wX[i] = p.x;
      wY[i] = p.y;
    }
  }

  let woundPath = null;
  function rebuildWoundPath() {
    if (TOTAL - freeCount <= 0) {
      woundPath = null;
      return;
    }
    const path = new Path2D();
    const xi = wX[freeCount], yi = wY[freeCount];
    path.moveTo(xi, yi);
    path.quadraticCurveTo(xi, yi, midpoint(xi, wX[freeCount + 1] || xi), midpoint(yi, wY[freeCount + 1] || yi));
    for (let i = freeCount + 1; i <= TOTAL - 2; i++) {
      path.moveTo(midpoint(wX[i - 1], wX[i]), midpoint(wY[i - 1], wY[i]));
      path.quadraticCurveTo(wX[i], wY[i], midpoint(wX[i], wX[i + 1]), midpoint(wY[i], wY[i + 1]));
    }
    woundPath = path;
  }

  function glue(i, x, y) {
    rX[i] = x;  rY[i] = y; vX[i] = 0; vY[i] = 0;
  }

  function updateAnchor() {
    if (freeCount > TOTAL - 1) return;
    const wx = ball.x + (wX[freeCount] * cos(ball.angle) - wY[freeCount] * sin(ball.angle)),
      wy = ball.y + (wX[freeCount] * sin(ball.angle) + wY[freeCount] * cos(ball.angle));
    glue(freeCount, wx, wy);
  }

  function initRope() {
    initWoundPath();
    rebuildWoundPath();
    updateAnchor();
  }

  initRope();

  function mouseImpulse() {
    if (!(mouse.down && !pMouse.down && freeCount < TOTAL)) {
      return;
    }
    const dX = mouse.x - ball.x, dY = mouse.y - ball.y;
    const d = hypot(dX, dY);
    const nX = dX / d, nY = min(dY / d, -sqrt(2) * 0.5);
    ball.vX += nX * 10;
    ball.vY += nY * 10;
    freeSegments(10);
  }

  // === Input ===
  const mouse = {x: 0, y: 0, down: false, t: performance.now()};
  let pMouse = {x: 0, y: 0, down: false, t: performance.now() - 0.01}
  const setMouse = (e, down = false) => {
    pMouse = {x: mouse.x, y: mouse.y, down: mouse.down, t: mouse.t};
    const r = C.getBoundingClientRect();
    mouse.x = e.clientX - r.left;
    mouse.y = e.clientY - r.top;
    mouse.down = down;
    mouse.t = performance.now();
  };
  C.addEventListener('pointermove', setMouse);
  C.addEventListener('pointerdown', e => {
    setMouse(e, true);
    mouseImpulse();
  });
  C.addEventListener('pointerup', () => mouse.down = false);

  // === Physics ===
  function integrateDisk(dt) {
    if (!ball.live) {
      ball.x = ball.y = -999;
      ball.vX = ball.vY = 0;
      ball.angle = 0;
      ball.omega = 0;
      ball.grounded = false;
      return;
    }
    ball.x += ball.vX * AIR;
    ball.y += (ball.vY += GRAV * dt * dt) * AIR;
    ball.angle += ball.omega * AIR;

    const {w, h} = world;
    ball.grounded = false;

    if (ball.y + R > h) {
      ball.y = h - R;
      ball.vY *= -REST;
      ball.grounded = true;
    } else if (ball.y - R < 0) {
      ball.y = R;
      ball.vY *= -WALL;
    }

    if (ball.x - R < 0) {
      ball.x = R;
      ball.vX *= -WALL;
    } else if (ball.x + R > w) {
      ball.x = w - R;
      ball.vX *= -WALL;
    }

    if (ball.grounded) {
      ball.omega = ball.vX / R;
      ball.vX *= 1 - GFRIC;
    }
  }

  function integrateTail(dt) {
    const {w, h} = world, g = GRAV * dt * dt;
    for (let i = 0; i < freeCount; i++) {
      rX[i] += vX[i];
      rY[i] += vY[i] += g;
      if (rY[i] > h) {
        rY[i] = h;
        vY[i] *= -REST;
        vX[i] *= GFRIC - 1;
      } else if (rY[i] < 0) {
        rY[i] = 0;
        vY[i] *= -WALL;
      }
      if (rX[i] < 0) {
        rX[i] = 0;
        vX[i] *= -WALL;
      } else if (rX[i] > w) {
        rX[i] = w;
        vX[i] *= -WALL;
      }
    }
  }

  function satisfy() {
    for (let k = 0; k < ITERS; k++) {
      for (let i = 1; i <= min(TOTAL - 1, freeCount); i++) {
        let dx = rX[i] - rX[i - 1], dy = rY[i] - rY[i - 1], d = hypot(dx, dy) || 1e-6, diff = (d - SEG) / d;
        let ma = .5, mb = .5;
        if (i >= freeCount && i - 1 >= freeCount) {
          ma = mb = 0;
        } else if (i >= freeCount) {
          ma = 1;
          mb = 0;
        } else if (i - 1 >= freeCount) {
          ma = 0;
          mb = 1;
        }
        rX[i - 1] += dx * diff * ma;
        rY[i - 1] += dy * diff * ma;
        rX[i] -= dx * diff * mb;
        rY[i] -= dy * diff * mb;
        if (i - 1 < freeCount && rY[i - 1] > world.h) rY[i - 1] = world.h;
        if (i < freeCount && rY[i] > world.h) rY[i] = world.h;
      }
    }
  }

  const freeSegments = (n = 1) => {
    const oldCount = freeCount;
    for (let k = 0; k < (n | 0) && freeCount < TOTAL; k++ & freeCount++) {
      const ca = cos(ball.angle), sa = sin(ball.angle);
      const rx =  wX[freeCount] * ca - wY[freeCount] * sa;
      const ry =  wX[freeCount] * sa + wY[freeCount] * ca;
      rX[freeCount] = ball.x + rx;
      rY[freeCount] = ball.y + ry;
      vX[freeCount] = ball.vX - ball.omega * ry;
      vY[freeCount] = ball.vY + ball.omega * rx;
      ball.live = freeCount < TOTAL;
    }
    if (freeCount !== oldCount) rebuildWoundPath();
  }

  // === Render ===
  function drawYarn() {
    X.lineCap = 'round';
    X.lineJoin = 'round';
    X.strokeStyle = '#d43375';
    X.globalAlpha = 1.0;
    X.lineWidth = 3;

    // --- draw the wound part (ball-local path) ---
    if (woundPath) {
      X.save();
      X.translate(ball.x, ball.y);
      X.rotate(ball.angle);
      X.stroke(woundPath);
      X.restore();
    }

    const nFree = min(freeCount, TOTAL);
    if (nFree <= 0) return;

    const mX = new Array(nFree - 1), mY = new Array(nFree - 1);
    for (let i = 0; i < nFree - 1; i++) {
      mX[i] = midpoint(rX[i], rX[i + 1]);
      mY[i] = midpoint(rY[i], rY[i + 1]);
    }
    X.beginPath();
    X.moveTo(rX[0], rY[0]);
    X.quadraticCurveTo(rX[1 - 1], rY[1 - 1], mX[0], mY[0]);
    for (let i = 1; i < nFree - 1; i++) {
      X.quadraticCurveTo(rX[i], rY[i], mX[i], mY[i]);
    }
    if (nFree < TOTAL) {
      const bX = ball.x + (wX[nFree] * cos(ball.angle) - wY[nFree] * sin(ball.angle)),
        bY = ball.y + (wX[nFree] * sin(ball.angle) + wY[nFree] * cos(ball.angle));
      X.quadraticCurveTo(rX[nFree], rY[nFree], midpoint(rX[nFree - 1], bX), midpoint(rY[nFree - 1], bY));
      X.quadraticCurveTo(bX, bY, bX, bY);
    } else {
      X.quadraticCurveTo(rX[nFree], rY[nFree], rX[nFree], rY[nFree]);
    }
    X.stroke();
  }


  // === Main loop ===
  let pStep = performance.now();
  function step(now) {
    const dt = clamp((now - pStep) / 1000, 0, 0.033);
    pStep = now;
    integrateDisk(dt)
    updateAnchor();
    integrateTail(dt);
    satisfy();
    freedLength = SEG * freeCount * ((TOTAL - 1) / TOTAL) / pxPerM;
    // Art
    X.fillStyle = '#222';
    X.fillRect(0, 0, world.w, world.h);
    X.strokeStyle = '#444';
    X.lineWidth = 50;
    X.beginPath();
    X.moveTo(0, world.h - 1);
    X.lineTo(world.w, world.h - 1);
    X.stroke();
    drawYarn();
    X.fillStyle = '#fff';
    X.font = '14px system-ui,sans-serif';
    X.fillText('yarn: ' + (freedLength.toFixed(1)) + ' m', 12, 22);
    requestAnimationFrame(step);
  }

  requestAnimationFrame(step);
});
</script>