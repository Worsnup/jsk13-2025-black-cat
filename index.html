<html lang="en"><head><title>Tangled</title><script>
 document.addEventListener('DOMContentLoaded', () => {
  // ===== Canvas bootstrap =====
  const $ = document, W = window, B = $.body, C = $.createElement('canvas'), X = C.getContext('2d');
  (document.getElementById('content') || B).innerHTML = '';
  Object.assign(B.style, {margin: 0, overflow: 'hidden'});
  Object.assign(C.style, {display: 'block', touchAction: 'none'});
  B.appendChild(C);

  // ===== Math helpers =====
  const {min, max, hypot, sqrt, sin, cos, PI} = Math;
  const clamp = (v, a, b) => max(a, min(b, v));
  const perpDot = (ax,ay,bx,by)=>ax*by-ay*bx; // 2D cross product magnitude

  // ===== World / DPI =====
  const DPR = min(2, W.devicePixelRatio || 1);
  function fitCanvasToWindow() {
   const w = W.innerWidth || $.documentElement.clientWidth;
   const h = W.innerHeight || $.documentElement.clientHeight;
   Object.assign(C.style, {width: w + 'px', height: h + 'px'});
   C.width = (w * DPR) | 0; C.height = (h * DPR) | 0;
   X.setTransform(DPR, 0, 0, DPR, 0, 0);
  }
  W.addEventListener('resize', fitCanvasToWindow);

  // ========================================
  // CONFIG
  // ========================================
  const TUNE = {
   SIM: {
    DT_S:                1/60,
    SUBSTEPS:            1,
    ITERS:               18,
    GRAVITY_MPS2:        [0, 9.81],
    DRAG:                0.01,
    BOUNDS_M:            [0, -1000, 8, 6],
    COLLIDE_CIRCLES:     true,
    CONTACT_COMPLIANCE_M_PER_N: 0,
    CONTACT_SLIDING_SLOP_M: 1e-3,

    // NEW: material properties for velocity-space resolution
    RESTITUTION:         0.20,   // bounciness (0..1)
    FRICTION:            0.55    // Coulomb μ
   },
   RENDER: {
    BG:                  '#121825',
    LINK_STROKE:         ['#e74688', '#d73779', '#cb2f6f'],
    LINK_PATTERN:        [0, 0, 1, 2, 1],
    LINK_WIDTH_PX:       8,
    PIXELS_PER_METER:    130,
    SHOW_BOUNDS:         false
   },
   GAME: {
    ROPE_COUNT:          1000,
    ROPE_START_M:        {x: 4, y: 0.8},
    ROPE_SEG_LEN_M:      0.10,
    ROPE_NODE_MASS_KG:   0.01,
    ROPE_NODE_RADIUS_M:  0.025,
    ROPE_STIFFNESS_N_PER_M: 1e8,

    BALL_POS_M:          {x: 6, y: 4.3},
    BALL_RADIUS_M:       0.30,
    BALL_MASS_KG:        2,

    MAX_FRAME_DT_S:      1/30,
    CLICK_POKE_N_PER_M:  300,


    MAX_LEVELS:           100,        // number of platform “floors”
    X_MARGIN_M:           0.6,             // keep platforms away from side walls
    PLATFORM_RADIUS_M:    0.10,            // capsule half-width
    PEG_RADIUS_M:         0.18,            // normal peg
    THORN_RADIUS_M:       0.15,            // thorn peg
    STEP_CHOICES_M:       [0.5, 1.0, 1.5], // vertical spacing between floors
    PEG_SPAWN_PROB:       0.50,            // chance to put a normal peg between floors
    THORN_START_DELTA_M:  25.0,             // no thorns until you've climbed this much
    THORN_PROB_AT_START:  0.00,            // thorn prob at threshold height
    THORN_PROB_AT_TOP:    0.80             // thorn prob near the top floors
   }
  };
  let INTRO_T0 = performance.now();

  // =========================
  // GAME STATE
  // =========================
  const GAME = {
   mode: 'playing',          // 'playing' | 'lost'
   clicks: 0,
   startY: TUNE.GAME.BALL_POS_M.y, // used for height = startY - ball.y
   best_m: 0,
   height_m: 0,
   msg: ''
  };
  function lose(msg){ GAME.mode='lost'; GAME.msg=msg; }
  function restartRun(){
   // Optional: you can rebuild the whole scene; for tonight just reload page
   location.reload();
  }

  // =========================
  // CAMERA / VIEW WINDOW
  // =========================
  const VIEW = {
   spanY_m: TUNE.SIM.BOUNDS_M[3], // screen shows ~6m tall; keep this constant
   minY: 0                        // start showing the original 0..6m range
  };

  // =========================
  // BACKGROUND "CAT EYES"
  // =========================
  const EYES = [];
  (function buildEyes() {
   // World spans from x=[bounds.x0..x1], y=[-1000..+6] per your BOUNDS_M edit
   const [BX0, BY0, BX1, BY1] = TUNE.SIM.BOUNDS_M;
   const W = BX1 - BX0;
   const H = BY1 - BY0; // ~1006m tall
   const COUNT = 300;   // tune this if you want more/less eyes
   for (let i = 0; i < COUNT; i++) {
    const x = BX0 + Math.random() * W;
    const y = BY0 + Math.random() * H; // uniformly sprinkled
    const r = 0.01 + Math.random() * 0.02; // pupil radius (m)
    const gap = 0.04 + Math.random() * 0.05; // distance between pupils (m)
    const a = 0.25 + Math.random() * 0.45; // opacity
    const twinkle = Math.random() * Math.PI * 2;
    // layer 0..1 for subtle parallax on x (super light)
    const layer = Math.random();
    EYES.push({x, y, r, gap, a, twinkle, layer});
   }
  })();


  // =========================
  // XPBD core + rigid augment
  // =========================
  const INTERNAL = { EPS_M: 1e-9, LAMBDA_DECAY: 1.0 };

  function XPBD(opt = {}) {
   const Wd = {
    dt: opt.dt ?? TUNE.SIM.DT_S,
    substeps: opt.substeps ?? TUNE.SIM.SUBSTEPS,
    iters: opt.iters ?? TUNE.SIM.ITERS,
    g: opt.g ?? TUNE.SIM.GRAVITY_MPS2.slice(),
    drag: opt.drag ?? TUNE.SIM.DRAG,
    bounds: opt.bounds ?? (TUNE.SIM.BOUNDS_M && TUNE.SIM.BOUNDS_M.slice()),
    contactCompliance: opt.contactCompliance ?? TUNE.SIM.CONTACT_COMPLIANCE_M_PER_N,
    collide: opt.collide ?? TUNE.SIM.COLLIDE_CIRCLES,

    e: opt.restitution ?? TUNE.SIM.RESTITUTION,
    mu: opt.friction ?? TUNE.SIM.FRICTION,

    P: [],  // point/particle nodes (rope)
    C: [],  // distance constraints
    T: [],  // tethers (unused here)
    R: [],  // NEW: rigid bodies (circles)
    K: []   // NEW: capsules (platforms)
   };

   // --- Particles (rope) ---
   function add(x_m, y_m, mass_kg = 1, radius_m = 0, col_mask=7, active=true) {
    const w = mass_kg > 0 ? 1 / mass_kg : 0;
    const p = { x: x_m, y: y_m, px: x_m, py: y_m, vx: 0, vy: 0, w, r: radius_m, col_mask, active, rigid:false };
    Wd.P.push(p); return p;
   }

   // --- NEW: Rigid circles (ball, pegs) ---
   function addRigidCircle(x, y, r, mass_kg = 0, col_mask=7, active=true) {
    const w = mass_kg > 0 ? 1 / mass_kg : 0;
    const I = mass_kg > 0 ? 0.5 * mass_kg * r * r : Infinity;   // solid disk
    const iI = mass_kg > 0 ? 1 / I : 0;
    const b = {
     x, y, px: x, py: y, vx: 0, vy: 0,
     w, r, col_mask, active,
     rigid: true,
     theta: 0, omega: 0, iI
    };
    Wd.R.push(b);
    return b;
   }

   // --- NEW: Capsules (platforms). Kinematic or static by default. ---
   function addCapsule(x1,y1,x2,y2,r, mass_kg=0, col_mask=7, active=true) {
    const w = mass_kg > 0 ? 1 / mass_kg : 0; // treat as rigid line w/ large inertia → no rotation for simplicity
    const cap = { x1, y1, x2, y2, r, w, col_mask, active, capsule:true };
    Wd.K.push(cap);
    return cap;
   }

   function link(a, b, rest_m = null, compliance_m_per_N = 0) {
    if (rest_m == null) { const dx = b.x - a.x, dy = b.y - a.y; rest_m = Math.hypot(dx, dy); }
    const c = { a, b, rest: rest_m, comp: compliance_m_per_N, lam: 0 };
    Wd.C.push(c); return c;
   }

   function addForce(p, Fx_N, Fy_N) {
    if (!p.w) return p;
    p.vx += (Fx_N * p.w) * Wd.dt;
    p.vy += (Fy_N * p.w) * Wd.dt;
    return p;
   }

   // Helpers for collision resolution (impulses)
   function applyImpulse(b, jx, jy, rx, ry) {
    if (!b.w && !b.iI) return;
    if (b.w) { b.vx += jx * b.w; b.vy += jy * b.w; }
    if (b.iI) { b.omega += b.iI * perpDot(rx, ry, jx, jy); }
   }

   function resolveContactImpulse(a, pa, b, pb, nx, ny, e, mu, pen=0, sdt=1/60, gDotN=0) {
    // pa/pb: world contact points on a/b
    // nx,ny: normal from a -> b (unit)
    const tax = -ny, tay = nx; // tangent

    const rax = pa.x - a.x, ray = pa.y - a.y;
    const rbx = pb.x - b.x, rby = pb.y - b.y;

    // relative velocity at contact
    const vax = a.vx + (-a.omega || 0) * ray; // ω × r = (-ω*ry, ω*rx)
    const vay = a.vy + ( a.omega || 0) * rax;
    const vbx = b.vx + (-b.omega || 0) * rby;
    const vby = b.vy + ( b.omega || 0) * rbx;

    const rvx = vbx - vax, rvy = vby - vay;

    // Effective mass along n and t
    const rnA = (a.w || 0) + (a.iI || 0) * (perpDot(rax, ray, nx, ny) ** 2);
    const rnB = (b.w || 0) + (b.iI || 0) * (perpDot(rbx, rby, nx, ny) ** 2);
    const rtA = (a.w || 0) + (a.iI || 0) * (perpDot(rax, ray, tax, tay) ** 2);
    const rtB = (b.w || 0) + (b.iI || 0) * (perpDot(rbx, rby, tax, tay) ** 2);

    const invEffN = rnA + rnB || 1e9;
    const invEffT = rtA + rtB || 1e9;

    const mEffN = 1 / (invEffN || 1e-9);       // effective normal mass
    const support = Math.max(0, gDotN) * mEffN * sdt; // impulse to resist closing accel

    // Normal impulse with restitution
    const vrel_n = rvx*nx + rvy*ny;
    const vrel_t = rvx*tax + rvy*tay;
    // Normal: restitution only if approaching; add small Baumgarte bias for sustained contact
    let jn = 0;
    if (vrel_n < 0) jn = -(1+e) * vrel_n / invEffN;
    const beta = 1; // contact bias factor
    const jn_bias = (pen > 0 ? (beta * pen / sdt) / invEffN : 0);
    const Jn = jn + jn_bias; // total normal impulse supporting contact
    if (Jn !== 0) {
     const jnx = Jn * nx, jny = Jn * ny;
     applyImpulse(a, -jnx, -jny, rax, ray);
     applyImpulse(b,  jnx,  jny, rbx, rby);
    }
    let jt = -vrel_t / invEffT;           // oppose tangential motion
    const maxF = mu * (Math.max(Jn, 0) + support);
    jt = clamp(jt, -maxF, maxF);
    const jtx = jt * tax, jty = jt * tay;
    applyImpulse(a, -jtx, -jty, rax, ray);
    applyImpulse(b,  jtx,  jty, rbx, rby);
   }

   function circleCircleContact(a, b) {
    const dx = b.x - a.x, dy = b.y - a.y;
    let d = Math.hypot(dx, dy); if (d < INTERNAL.EPS_M) d = INTERNAL.EPS_M;
    const rs = (a.r || 0) + (b.r || 0);
    return { hit: d < rs, d, nx: dx/d, ny: dy/d, pen: rs - d };
   }

   function closestPointOnSegment(px,py, ax,ay, bx,by) {
    const abx = bx-ax, aby = by-ay;
    const ab2 = abx*abx + aby*aby || 1;
    let t = ((px-ax)*abx + (py-ay)*aby) / ab2;
    t = clamp(t, 0, 1);
    return { x: ax + t*abx, y: ay + t*aby, t };
   }

   function circleCapsuleContact(c, cap) {
    const q = closestPointOnSegment(c.x, c.y, cap.x1, cap.y1, cap.x2, cap.y2);
    const dx = c.x - q.x, dy = c.y - q.y;
    let d = Math.hypot(dx, dy) || INTERNAL.EPS_M;
    const rs = (c.r||0) + cap.r;
    const hit = d < rs + TUNE.SIM.CONTACT_SLIDING_SLOP_M;
    const pen = Math.max(0, rs - d);
    return { hit, d, nx: dx/d, ny: dy/d, pen, pc: {x:q.x, y:q.y} };
   }

   function step(dt = Wd.dt) {
    const P = Wd.P, Cn = Wd.C, Th = Wd.T, Rg = Wd.R;
    const g = Wd.g, drag = Wd.drag, sub = Wd.substeps, it = Wd.iters;
    const hasBounds = !!Wd.bounds, B = Wd.bounds;
    const doCollide = !!Wd.collide;
    const e = Wd.e, mu = Wd.mu;

    const sdt = dt / sub;
    const invDrag = 1 / (1 + drag);
    const alphaScale = sdt * sdt;

    for (let s = 0; s < sub; s++) {
     // integrate (particles)
     for (let i = 0; i < P.length; i++) {
      const p = P[i]; if (!p.active) continue;
      p.px = p.x; p.py = p.y;
      if (!p.w) continue;
      p.vx += g[0] * sdt; p.vy += g[1] * sdt;
      p.vx *= invDrag;    p.vy *= invDrag;
      p.x += p.vx * sdt;  p.y += p.vy * sdt;
     }

     // integrate (rigid circles)
     for (let i = 0; i < Rg.length; i++) {
      const b = Rg[i]; if (!b.active) continue;
      b.px = b.x; b.py = b.y;
      if (b.w) {
       b.vx += g[0] * sdt; b.vy += g[1] * sdt;
       b.vx *= invDrag;    b.vy *= invDrag;
       b.x  += b.vx * sdt; b.y  += b.vy * sdt;
      }
      b.theta += b.omega * sdt;
     }

     // solver iterations (rope constraints & positional contacts)
     for (let k = 0; k < it; k++) {
      // Tethers (unused)
      for (let i = 0; i < Th.length; i++) {
       const t = Th[i], a = t.a, b = t.b;
       let dx = a.x - b.x, dy = a.y - b.y;
       let d = Math.hypot(dx, dy); if (d < INTERNAL.EPS_M) d = INTERNAL.EPS_M;
       const Cval = t.max - d; if (Cval >= 0) { t.lam = 0; continue; }
       const nx = dx / d, ny = dy / d;
       const wsum = a.w + b.w; if (wsum === 0) continue;
       const alpha = (t.comp || 0) / alphaScale;
       const oldLam = Math.max(0, t.lam) * INTERNAL.LAMBDA_DECAY;
       let dlam = (-Cval - alpha * oldLam) / (wsum + alpha);
       let newLam = oldLam + dlam;
       if (newLam < 0) { dlam = -oldLam; newLam = 0; }
       const px = dlam * nx, py = dlam * ny;
       if (a.w) { a.x -= px * a.w; a.y -= py * a.w; }
       if (b.w) { b.x += px * b.w; b.y += py * b.w; }
       t.lam = newLam;
      }

      // Distance constraints (rope)
      for (let i = 0; i < Cn.length; i++) {
       const c = Cn[i], a = c.a, b = c.b;
       let dx = b.x - a.x, dy = b.y - a.y;
       const d = Math.hypot(dx, dy); if (d < INTERNAL.EPS_M) continue;
       const nx = dx / d, ny = dy / d;
       const Cval = d - c.rest;
       const wsum = a.w + b.w; if (wsum === 0) { c.lam = 0; continue; }
       const alpha = (c.comp || 0) / alphaScale;
       const oldLam = c.lam * INTERNAL.LAMBDA_DECAY;
       const dlam = (-Cval - alpha * oldLam) / (wsum + alpha);
       c.lam = oldLam + dlam;
       const px = dlam * nx, py = dlam * ny;
       if (a.w) { a.x -= px * a.w; a.y -= py * a.w; }
       if (b.w) { b.x += px * b.w; b.y += py * b.w; }
      }

      // Bounds (positional clamp only)
      if (hasBounds) {
       const [minx, miny, maxx, maxy] = B;
       for (let i = 0; i < P.length; i++) {
        const p = P[i]; if (!p.active) continue;
        const r = p.r || 0;
        if (p.x < minx + r) p.x = minx + r;
        if (p.x > maxx - r) p.x = maxx - r;
        if (p.y < miny + r) p.y = miny + r;
        if (p.y > maxy - r) p.y = maxy - r;
       }
       for (let i = 0; i < Rg.length; i++) {
        const b = Rg[i]; if (!b.active) continue;
        const r = b.r || 0;
        if (b.x < minx + r) b.x = minx + r;
        if (b.x > maxx - r) b.x = maxx - r;
        if (b.y < miny + r) b.y = miny + r;
        if (b.y > maxy - r) b.y = maxy - r;
       }
      }

      // Positional contact projection (keeps XPBD stability)
      if (doCollide) {
       // circle–circle among rigids
       for (let i = 0; i < Rg.length; i++) {
        const a = Rg[i]; if (!a.active) continue;
        for (let j = i + 1; j < Rg.length; j++) {
         const b = Rg[j]; if (!b.active) continue;
         if ((a.col_mask & b.col_mask) === 0) continue;
         const cc = circleCircleContact(a,b); if (!cc.hit) continue;
         const wsum = a.w + b.w; if (wsum === 0) continue;
         const corr = cc.pen / wsum;
         if (a.w) { a.x -= cc.nx * corr * a.w; a.y -= cc.ny * corr * a.w; }
         if (b.w) { b.x += cc.nx * corr * b.w; b.y += cc.ny * corr * b.w; }
        }
       }
       // circle–capsule: rigid vs platform
       for (let i = 0; i < Rg.length; i++) {
        const c = Rg[i]; if (!c.active) continue;
        for (let j = 0; j < Wd.K.length; j++) {
         const cap = Wd.K[j]; if (!cap.active) continue;
         if ((c.col_mask & cap.col_mask) === 0) continue;
         const ck = circleCapsuleContact(c, cap); if (!ck.hit) continue;
         if (c.w) { c.x += ck.nx * ck.pen; c.y += ck.ny * ck.pen; } // capsule is static by default
        }
       }
       // rope particles vs capsules
       for (let i = 0; i < P.length; i++) {
        const a = P[i]; if (!a.active || !a.r) continue;
        if (!a.w) continue;
        for (let j = 0; j < Wd.K.length; j++) {
         const cap = Wd.K[j]; if (!cap.active) continue;
         if ((a.col_mask & cap.col_mask) === 0) continue;
         const ck = circleCapsuleContact(a, cap);
         if (!ck.hit) continue;
         a.x += ck.nx * ck.pen;
         a.y += ck.ny * ck.pen;
        }
       }
       // rope particles vs rigid circles (peg/ball/etc) if desired
       for (let i = 0; i < P.length; i++) {
        const a = P[i]; if (!a.active || !a.r) continue;
        for (let j = 0; j < Rg.length; j++) {
         const b = Rg[j]; if (!b.active || !b.r) continue;
         if ((a.col_mask & b.col_mask) === 0) continue;
         const cc = circleCircleContact(a,b); if (!cc.hit) continue;
         const wsum = a.w + b.w; if (wsum === 0) continue;
         const corr = cc.pen / wsum;
         if (a.w) { a.x -= cc.nx * corr * a.w; a.y -= cc.ny * corr * a.w; }
         if (b.w) { b.x += cc.nx * corr * b.w; b.y += cc.ny * corr * b.w; }
        }
       }
      }
     } // end iterations

     // velocity update from positions
     for (let i = 0; i < P.length; i++) {
      const p = P[i]; if (!p.active) continue;
      p.vx = (p.x - p.px) / sdt;
      p.vy = (p.y - p.py) / sdt;
     }
     for (let i = 0; i < Rg.length; i++) {
      const b = Rg[i]; if (!b.active) continue;
      b.vx = (b.x - b.px) / sdt;
      b.vy = (b.y - b.py) / sdt;
     }

     // NEW: velocity-space impulses (spin + friction + restitution)
     if (doCollide) {
      // rigid–rigid
      for (let i = 0; i < Rg.length; i++) {
       const a = Rg[i]; if (!a.active) continue;
       for (let j = i + 1; j < Rg.length; j++) {
        const b = Rg[j]; if (!b.active) continue;
        if ((a.col_mask & b.col_mask) === 0) continue;
        const cc = circleCircleContact(a,b); if (!cc.hit) continue;
        // contact points on surfaces
        const pa = { x: a.x + cc.nx * ( a.r), y: a.y + cc.ny * ( a.r) };
        const pb = { x: b.x - cc.nx * ( b.r), y: b.y - cc.ny * ( b.r) };
        const gDotN = ((a.w?1:0) - (b.w?1:0)) * (Wd.g[0]*cc.nx + Wd.g[1]*cc.ny);
        resolveContactImpulse(a, pa, b, pb, cc.nx, cc.ny, e, mu, cc.pen, sdt, gDotN);
       }
      }
      // rigid–capsule
      for (let i = 0; i < Rg.length; i++) {
       const c = Rg[i]; if (!c.active) continue;
       for (let j = 0; j < Wd.K.length; j++) {
        const cap = Wd.K[j]; if (!cap.active) continue;
        if ((c.col_mask & cap.col_mask) === 0) continue;
        const ck = circleCapsuleContact(c, cap); if (!ck.hit) continue;
        // static/kinematic capsule → only body gets impulse
        const pb = { x: ck.pc.x, y: ck.pc.y }; // plane point
        const nx = -ck.nx, ny = -ck.ny;
        const gDotN = (Wd.g[0]*nx + Wd.g[1]*ny); // gravity pushing a into b?
        resolveContactImpulse(c, {x: c.x - ck.nx * c.r, y: c.y - ck.ny * c.r},
          {x: cap.x1, y: cap.y1, vx:0, vy:0, omega:0, w:0, iI:0}, pb, nx, ny, e, mu, ck.pen, sdt, gDotN);
       }
      }
      // bounds impulses for rigids (treat as static planes)
      if (hasBounds) {
       const [minx, miny, maxx, maxy] = B;
       for (let i = 0; i < Rg.length; i++) {
        const b = Rg[i]; if (!b.active) continue;
        // left/right
        if (b.x - b.r <= minx) resolveContactImpulse(
         b, {x:minx, y:b.y}, {x:0,y:0,vx:0,vy:0,omega:0,w:0,iI:0}, {x:minx,y:b.y}, 1,0, e, mu
        );
        if (b.x + b.r >= maxx) resolveContactImpulse(
         b, {x:maxx, y:b.y}, {x:0,y:0,vx:0,vy:0,omega:0,w:0,iI:0}, {x:maxx,y:b.y}, -1,0, e, mu
        );
        if (b.y - b.r <= miny) resolveContactImpulse(
         b, {x:b.x, y:miny}, {x:0,y:0,vx:0,vy:0,omega:0,w:0,iI:0}, {x:b.x,y:miny}, 0,1, e, mu
        );
        if (b.y + b.r >= maxy) resolveContactImpulse(
         b, {x:b.x, y:maxy}, {x:0,y:0,vx:0,vy:0,omega:0,w:0,iI:0}, {x:b.x,y:maxy}, 0,-1, e, mu
        );
       }
      }
     }
    } // substeps
   } // step

   function stiffnessToCompliance(k_N_per_m) { return k_N_per_m > 0 ? 1 / k_N_per_m : 0; }
   return {
    P: Wd.P, C: Wd.C, T: Wd.T, R: Wd.R, K: Wd.K,
    get dt() { return Wd.dt; }, set dt(v) { Wd.dt = v; },
    get iters() { return Wd.iters; }, set iters(v) { Wd.iters = v | 0; },
    get substeps() { return Wd.substeps; }, set substeps(v) { Wd.substeps = v | 0; },
    get gravity() { return Wd.g; }, set gravity(g) { Wd.g = g; },
    get bounds() { return Wd.bounds; }, set bounds(b) { Wd.bounds = b; },
    get collide() { return Wd.collide; }, set collide(v) { Wd.collide = !!v; },
    add, addRigidCircle, addCapsule, link, addForce, step, stiffnessToCompliance
   };
  }

  // =====================
  // Simulator (ALL physics)
  // =====================
  function makeSimulator() {
   const sim = XPBD({
    dt: TUNE.SIM.DT_S,
    iters: TUNE.SIM.ITERS,
    substeps: TUNE.SIM.SUBSTEPS,
    g: TUNE.SIM.GRAVITY_MPS2,
    bounds: TUNE.SIM.BOUNDS_M,
    collide: TUNE.SIM.COLLIDE_CIRCLES,
    contactCompliance: TUNE.SIM.CONTACT_COMPLIANCE_M_PER_N,
    restitution: TUNE.SIM.RESTITUTION,
    friction: TUNE.SIM.FRICTION,
   });

   // --- Tower generation (REPLACES the single platform/floor/peg section) ---
   const plats = [];    // platforms (capsules)
   const pegs = [];     // normal pegs (rigid circles)
   const thorns = [];   // thorn pegs (rigid circles) — hazards

   const [BX0, BY0, BX1, BY1] = TUNE.SIM.BOUNDS_M;
   const BW = BX1 - BX0, BH = BY1 - BY0;

// Floor (keep it; it’s the “bottom”)
   const floor = sim.addCapsule(BX0 - BW, BY1, BX1 + BW, BY1, 0.12, 0, 7, true);
   plats.push(floor);

// One quick platform near the start (quality-of-life)
   plats.push(sim.addCapsule(BX0 + BW*0.15, BY1 - 0.9, BX1 - BW*0.15, BY1 - 1.0, TUNE.GAME.PLATFORM_RADIUS_M, 0, 7, true));

   function rand(a,b){ return a + Math.random()*(b-a); }
   function choice(a){ return a[(Math.random()*a.length)|0]; }

// Build platforms from bottom upward (lower y → “higher”)
   let currentY = BY1 - 1.2; // start a bit above floor
   for (let i = 0; i < TUNE.GAME.MAX_LEVELS; i++) {
    const dy = choice(TUNE.GAME.STEP_CHOICES_M);
    const nextY = currentY - dy;

    // Random x placement with margin
    const xL = BX0 + TUNE.GAME.X_MARGIN_M;
    const xR = BX1 - TUNE.GAME.X_MARGIN_M;
    const x1 = rand(xL, xR - 2.0);
    const x2 = x1 + rand(1.2, 2.4);              // platform span
    plats.push(sim.addCapsule(x1, nextY, Math.min(x2, xR), nextY + rand(-0.05,0.05), TUNE.GAME.PLATFORM_RADIUS_M, 0, 7, true));

    // Between this and previous floor, maybe spawn a peg
    const midY = (currentY + nextY) * 0.5;
    const midX = rand(xL, xR);
    const climbed_m = (TUNE.GAME.BALL_POS_M.y - nextY); // how far above start this floor sits

    // Thorn probability ramps after threshold
    const over = Math.max(0, climbed_m - TUNE.GAME.THORN_START_DELTA_M);
    const ramp = Math.min(1, over / (BH*0.8)); // gentle ramp
    const thornProb = TUNE.GAME.THORN_PROB_AT_START * (1 - ramp) + TUNE.GAME.THORN_PROB_AT_TOP * ramp;

    if (Math.random() < TUNE.GAME.PEG_SPAWN_PROB) {
     if (Math.random() < thornProb) {
      thorns.push(sim.addRigidCircle(midX, midY, TUNE.GAME.THORN_RADIUS_M, 0, 7, true));
     } else {
      pegs.push(sim.addRigidCircle(midX, midY, TUNE.GAME.PEG_RADIUS_M, 0, 7, true));
     }
    }

    currentY = nextY;
   }

   // --- Rope + ball ---
   const N = TUNE.GAME.ROPE_COUNT;
   const start = TUNE.GAME.ROPE_START_M;
   const segLen = TUNE.GAME.ROPE_SEG_LEN_M;
   const rope = [];
   let prev = sim.add(start.x, start.y, TUNE.GAME.ROPE_NODE_MASS_KG, TUNE.GAME.ROPE_NODE_RADIUS_M, 0);
   rope.push(prev);
   for (let i = 1; i < N; i++) {
    const p = sim.add(start.x + i * segLen, start.y, TUNE.GAME.ROPE_NODE_MASS_KG, TUNE.GAME.ROPE_NODE_RADIUS_M, 0);
    sim.link(prev, p, segLen, sim.stiffnessToCompliance(TUNE.GAME.ROPE_STIFFNESS_N_PER_M));
    rope.push(p);
    prev = p;
   }
   const ball = sim.addRigidCircle(
    TUNE.GAME.BALL_POS_M.x, TUNE.GAME.BALL_POS_M.y,
    TUNE.GAME.BALL_RADIUS_M, TUNE.GAME.BALL_MASS_KG,
    1, true
   );

   // --- Wound path + free logic (unchanged structurally) ---
   function buildWoundPath(total, segLen_m, R_m) {
    const wX = new Array(total).fill(0), wY = new Array(total).fill(0);
    const inner = 0, outer = R_m;
    const locals = [];
    const pushFar = p => {
     if (!locals.length) { locals.push(p); return; }
     const q = locals[locals.length - 1], d = hypot(p.x - q.x, p.y - q.y);
     const nx = (p.x - q.x) / (d || 1), ny = (p.y - q.y) / (d || 1);
     locals.push({ x: q.x + nx * segLen_m, y: q.y + ny * segLen_m });
    };
    pushFar({ x: outer, y: outer });
    const limit = total - locals.length;
    let dir = 1;
    for (let i = 0; i < limit; i++) {
     if (Math.random() < 0.2) { dir *= -1; }
     const angle = dir * i * (segLen_m / (2 * PI * outer)) * 2 * PI;
     const r = (outer - inner) * sqrt(1 - i / limit) + inner;
     const p = { x: r * cos(angle), y: r * sin(angle)};
     pushFar(p);
    }
    for (let i = 0; i < total; i++) { const p = locals[i] || locals[locals.length - 1]; wX[i] = p.x; wY[i] = p.y; }
    const wR = new Array(total).fill(0);
    for (let i = 1; i < total; i++) wR[i] = hypot(wX[i], wY[i]);
    return { wX, wY, wR };
   }
   const woundLocal = buildWoundPath(N, segLen, TUNE.GAME.BALL_RADIUS_M);
   let freeCount = 0;

   function worldAnchor(i, cx, cy, ang = 0) {
    const ca = cos(ang), sa = sin(ang);
    const wx = cx + (woundLocal.wX[i] * ca - woundLocal.wY[i] * sa);
    const wy = cy + (woundLocal.wX[i] * sa + woundLocal.wY[i] * ca);
    return { x: wx, y: wy };
   }

   (function layoutInitial() {
    for (let i = 0; i < N; i++) { rope[i].w = 0; }
    rope[0].w = 0; freeCount = 0;
   })();

   function freeSegments(n = 1) {
    for (let k = 0; k < n && freeCount < N; k++) {
     const idx = freeCount;
     const p = rope[idx];
     p.w = 1 / TUNE.GAME.ROPE_NODE_MASS_KG;
     const dx = p.x - ball.x, dy = p.y - ball.y;
     // ω × r = (-ω*ry, ω*rx)
     p.vx = ball.vx + (-ball.omega) * dy;
     p.vy = ball.vy + ( ball.omega) * dx;
     p.col_mask = 2;
     freeCount++;
    }
    if (freeCount < N) {
     rope[freeCount].w = 0;
     let totalRad = 0;
     const limit = min(max(25, 0.1 * (N - freeCount)), N - freeCount);
     for (let i = 0; i < limit; i++) totalRad += woundLocal.wR[i + freeCount];
     ball.r = max(0.05, totalRad / limit);
    } else {
     ball.active = false;
    }
   }

   function advance(dt) {
    // Kinematic wound section follows ball orientation (can later use ball.theta)
    if (freeCount < N) {
     const pin = rope[freeCount];
     const a0 = worldAnchor(freeCount, ball.x, ball.y, ball.theta);
     pin.x = a0.x; pin.y = a0.y; pin.px = a0.x; pin.py = a0.y;
    }
    for (let i = freeCount + 1; i < N; i++) {
     const p = rope[i];
     const a = worldAnchor(i, ball.x, ball.y, ball.theta);
     p.x = a.x; p.y = a.y; p.px = a.x; p.py = a.y; p.vx = 0; p.vy = 0; p.w = 0;
    }
    sim.step(dt);
   }

   function applyPoke(wx, wy, k = TUNE.GAME.CLICK_POKE_N_PER_M) {
    sim.addForce(ball, (wx - ball.x) * k, (wy - ball.y) * k);
   }

   function getRenderData() {
    const tailCount = Math.min(freeCount, N);
    const tail = [];
    for (let i = 0; i < tailCount; i++) tail.push({ x: rope[i].x, y: rope[i].y });

    const wound = [];
    if (freeCount < N - 1) {
     for (let i = freeCount; i < N; i++) {
      const a = worldAnchor(i, ball.x, ball.y, ball.theta);
      wound.push(a);
     }
    }
    const freedLength_m = TUNE.GAME.ROPE_SEG_LEN_M * freeCount;

    return {
     bounds: TUNE.SIM.BOUNDS_M.slice(),
     tail, wound,
     ball: { x: ball.x, y: ball.y, r: ball.r, active: ball.active, theta: ball.theta, vx: ball.vx, vy: ball.vy },
     hud: { freedLength_m },
     platforms: plats.map(c => ({ r:c.r, x1:c.x1, y1:c.y1, x2:c.x2, y2:c.y2 })),  // NEW
     pegs: pegs.map(p => ({ x:p.x, y:p.y, r:p.r })),                               // NEW
     thorns: thorns.map(p => ({ x:p.x, y:p.y, r:p.r }))                             // NEW
    };
   }

   return { advance, freeSegments, applyPoke, getRenderData };
  }

  // ==================================
  // Renderer (ALL graphics) — unchanged API
  // ==================================
  function makeRenderer() {
   const cfg = {
    pixelsPerMeter: TUNE.RENDER.PIXELS_PER_METER,
    bg: TUNE.RENDER.BG,
    linkStroke: TUNE.RENDER.LINK_STROKE,
    linkPattern: TUNE.RENDER.LINK_PATTERN,
    linkWidth: TUNE.RENDER.LINK_WIDTH_PX,
    showBounds: TUNE.RENDER.SHOW_BOUNDS
   };
   const S = cfg.pixelsPerMeter;

   function clear() {
    X.fillStyle = cfg.bg;
    X.fillRect(0, 0, C.clientWidth, C.clientHeight);
   }
   function toPx(bounds, x, y) {
    const [BX0, BY0] = bounds;
    return [(x - BX0) * S, (y - BY0) * S];
   }
   function toLen(lm) { return lm * S; }

   function drawStaticsAndHUD(state) {
    const {bounds, platforms, pegs, thorns, ball, hud} = state;

    // platforms (capsules)
    X.strokeStyle = '#666'; X.lineCap = 'round';
    for (const cap of platforms) {
     X.lineWidth = cap.r * S * 2;
     const p0 = toPx(bounds, cap.x1, cap.y1);
     const p1 = toPx(bounds, cap.x2, cap.y2);
     X.beginPath(); X.moveTo(p0[0], p0[1]); X.lineTo(p1[0], p1[1]); X.stroke();
    }

    // normal pegs
    X.fillStyle = '#888';
    for (const p of pegs) {
     const q = toPx(bounds, p.x, p.y);
     X.beginPath(); X.arc(q[0], q[1], toLen(p.r), 0, Math.PI*2); X.fill();
    }

    // thorn pegs (hazards)
    X.fillStyle = '#c0392b';
    for (const p of thorns) {
     const q = toPx(bounds, p.x, p.y);
     X.beginPath(); X.arc(q[0], q[1], toLen(p.r), 0, Math.PI*2); X.fill();
     // quick “spikes” (pure cosmetic): short star lines
     const spikes = 6, R = toLen(p.r), r = R*1.25;
     X.beginPath();
     for (let i=0;i<spikes;i++){
      const a = (i / spikes) * Math.PI*2;
      X.moveTo(q[0] + Math.cos(a)*R, q[1] + Math.sin(a)*R);
      X.lineTo(q[0] + Math.cos(a)*r, q[1] + Math.sin(a)*r);
     }
     X.strokeStyle = '#c0392b'; X.lineWidth = 2; X.stroke();
    }

    // HUD
    X.fillStyle = '#fff'; X.font = '14px system-ui,sans-serif';
    const yarnLeft = Math.max(0, 100.0 - hud.freedLength_m);
    X.fillText('yarn left: ' + yarnLeft.toFixed(1) + ' m', 12, 22);
    X.fillText('height: ' + (GAME.startY - ball.y).toFixed(1) + ' m', 12, 42);
    X.fillText('best: ' + GAME.best_m.toFixed(1) + ' m', 12, 62);
    if (GAME.mode === 'lost') X.fillText(GAME.msg + '  (click to restart)', 12, 84);

    const t = performance.now() - INTRO_T0;
    if (t < 10000) {
     X.globalAlpha = 0.8;
     X.fillStyle = '#d8d8ff';
     X.font = '13px system-ui,sans-serif';
     X.fillText('A black cat must climb the tower before dawn, but its yarn is limited…', 12, 82);
     X.globalAlpha = 1;
    }
   }

   function drawYarnCurve(pts) {
    if (!pts || pts.length < 2) return;
    const n = pts.length - 1, m = Array(n);
    const mp = (a, b) => [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];
    for (let i = 0; i < n; i++) {
     m[i] = mp(pts[i], pts[i + 1]);
    }
    let colorIdx = 0, color = cfg.linkStroke[cfg.linkPattern[colorIdx]];
    X.save();
    X.lineWidth = cfg.linkWidth; X.lineCap = 'round'; X.lineJoin = 'round'; X.strokeStyle = color;
    X.beginPath(); X.moveTo(pts[0][0], pts[0][1]);
    for (let i = 0; i < n; i++) {
     X.quadraticCurveTo(pts[i][0], pts[i][1], m[i][0], m[i][1]);
     colorIdx = (colorIdx + 1) % cfg.linkPattern.length;
     let newColor = cfg.linkStroke[cfg.linkPattern[colorIdx]];
     if (newColor !== color) {
      X.stroke();
      X.beginPath();
      X.moveTo(m[i][0], m[i][1]);
      X.strokeStyle = color = newColor;
     }
    }
    X.quadraticCurveTo(pts[n][0], pts[n][1], pts[n][0], pts[n][1]);
    X.stroke();
    X.restore();
   }

   function drawYarn(state) {
    const {bounds, tail, wound} = state;
    const m = tail.concat(wound), n = m.length;
    if (n < 2) return;
    for (let i = 0; i < n; i++) m[i] = toPx(bounds, m[i].x, m[i].y);
    drawYarnCurve(m);
   }

   function drawEyes(viewBounds){
    // Only draw eyes that are inside the camera slice to keep it cheap
    const [BX0, BY0, BX1, BY1] = viewBounds;
    const margin = 0.5; // draw a bit beyond edges to avoid popping
    const now = performance.now() * 0.002;

    X.save();
    for (const e of EYES) {
     if (e.y < BY0 - margin || e.y > BY1 + margin) continue;

     // subtle parallax on x: nudge by camera vertical (layer-dependent)
     const parallaxX = (BY0) * 0.02 * (e.layer - 0.5);
     const ex = e.x + parallaxX;

     // both pupils in world space
     const L = toPx(viewBounds, ex - e.gap*0.5, e.y);
     const R = toPx(viewBounds, ex + e.gap*0.5, e.y);
     const rp = toLen(e.r);

     // twinkle: breathe radius a tiny bit
     const tw = (Math.sin(now + e.twinkle) * 0.15 + 0.85);
     const rr = rp * tw;

     // glow
     X.globalAlpha = e.a * 0.6;
     X.shadowColor = '#e6fffa';
     X.shadowBlur = rr * 3.0;
     X.fillStyle = '#e6fffa';

     X.beginPath(); X.arc(L[0], L[1], rr, 0, Math.PI*2); X.fill();
     X.beginPath(); X.arc(R[0], R[1], rr, 0, Math.PI*2); X.fill();

     // reset per eye to avoid compounding blur
     X.shadowBlur = 0;
    }
    X.restore();
   }

   function draw(state, viewBounds) {
    clear();
    const b = viewBounds || state.bounds;
    const proxy = Object.assign({}, state, {bounds: b});
    drawEyes(b);
    drawYarn(proxy);
    drawStaticsAndHUD(proxy);
   }

   function screenToMeters(bounds, clientX, clientY) {
    const rect = C.getBoundingClientRect();
    const lx = (clientX - rect.left) / DPR;
    const ly = (clientY - rect.top) / DPR;
    const [BX0, BY0] = bounds;
    return { x: BX0 + lx / S, y: BY0 + ly / S };
   }

   return { draw, screenToMeters };
  }

  // =====================
  // Wire-up
  // =====================
  const simCtl = makeSimulator();
  const renderer = makeRenderer();

  // =====================
  // Animate
  // =====================
  fitCanvasToWindow();
  let last = performance.now();
  function tick(t) {
   const dt = clamp((t - last) / 1000, 0, TUNE.GAME.MAX_FRAME_DT_S);
   last = t;

   simCtl.advance(dt);
   const state = simCtl.getRenderData();

   // === Camera follow (render-only) ===
   const targetMinY = state.ball.y - 2.5; // keep ball ~2.5m from top
   if (targetMinY < VIEW.minY) {
     // smooth upward pan (optional), or just snap:
     VIEW.minY = 0.85 * VIEW.minY + 0.15 * targetMinY;
   }
   if (targetMinY > VIEW.minY + 5) {
    // smooth downward pan
    VIEW.minY = 0.97 * VIEW.minY + 0.03 * targetMinY;
   }
   const viewBounds = [
     state.bounds[0],
     VIEW.minY,
     state.bounds[2],
     VIEW.minY + VIEW.spanY_m
   ];

   // Score (higher = better). “Climb” is decreasing y, so height = startY - current y
   GAME.height_m = Math.max(0, GAME.startY - state.ball.y);
   if (GAME.height_m > GAME.best_m) GAME.best_m = GAME.height_m;

   if (GAME.mode === 'playing') {
    // A) Out of yarn → ball becomes inactive in your sim; end run
    if (!state.ball.active) {
     lose('Out of yarn');
    }

    // B) Fell off bottom: near lower bound (BY1)
    const BY1 = state.bounds[3];
    if (state.ball.y >= BY1 - 0.01) {
     lose('You fell');
    }

    // C) Hit thorn (ball or any tail node)
    if (hitThorn(state)) {
     lose('Thorned!');
    }
   }

   renderer.draw(state, viewBounds);
   requestAnimationFrame(tick);
  }

// Thorn collision check (cheap distance tests)
  function hitThorn(state){
   const thorns = state.thorns || [];
   if (!thorns.length) return false;

   // Ball vs thorns
   for (const h of thorns) {
    const dx = state.ball.x - h.x, dy = state.ball.y - h.y;
    if (Math.hypot(dx,dy) <= state.ball.r + h.r) return true;
   }
   // Tail points vs thorns (nodes are small circles)
   const nr = TUNE.GAME.ROPE_NODE_RADIUS_M;
   for (const p of state.tail) {
    for (const h of thorns) {
     const dx = p.x - h.x, dy = p.y - h.y;
     if (Math.hypot(dx,dy) <= nr + h.r) return true;
    }
   }
   return false;
  }

  requestAnimationFrame(tick);

  // =====================
  // Input
  // =====================
  C.addEventListener('click', e => {
   if (GAME.mode === 'lost') { restartRun(); return; }

   GAME.clicks++;
   const state = simCtl.getRenderData();
   const viewBounds = [state.bounds[0], VIEW.minY, state.bounds[2], VIEW.minY + VIEW.spanY_m];
   const wp = renderer.screenToMeters(viewBounds, e.clientX, e.clientY);
   simCtl.applyPoke(wp.x, wp.y, TUNE.GAME.CLICK_POKE_N_PER_M);

   // Only unspool if yarn remains (freeSegments no-op once it hits total, but be explicit)
   simCtl.freeSegments(10);
  });
 });
</script></head></html>