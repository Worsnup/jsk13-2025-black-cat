<!-- TODO 2. Add collisions with static bodies -->
<!-- TODO 3. Need to optimize so it runs 1000 node rope easily -->

<script>
 document.addEventListener('DOMContentLoaded', () => {
  // ===== Canvas bootstrap =====
  const $ = document, W = window, B = $.body, C = $.createElement('canvas'), X = C.getContext('2d');
  (document.getElementById('content') || B).innerHTML = '';
  Object.assign(B.style, {margin: 0, overflow: 'hidden'});
  Object.assign(C.style, {display: 'block', touchAction: 'none'});
  B.appendChild(C);

  // ===== Math helpers =====
  const {min, max, hypot, sin, cos, PI, atan2, random} = Math;
  const clamp = (v, a, b) => max(a, min(b, v));

  // ===== World / DPI =====
  const DPR = min(2, W.devicePixelRatio || 1);
  function fitCanvasToWindow() {
   const w = W.innerWidth || $.documentElement.clientWidth;
   const h = W.innerHeight || $.documentElement.clientHeight;
   Object.assign(C.style, {width: w + 'px', height: h + 'px'});
   C.width = (w * DPR) | 0; C.height = (h * DPR) | 0;
   X.setTransform(DPR, 0, 0, DPR, 0, 0);
   // renderer handles its own scaling; simulator works only in meters.
  }
  W.addEventListener('resize', fitCanvasToWindow);

  // ========================================
  // CONFIG: TUNABLE
  // ========================================
  const TUNE = {
   SIM: {
    DT_S:                1/60,
    SUBSTEPS:            1,
    ITERS:               18,
    GRAVITY_MPS2:        [0, 9.81],
    DRAG:                0.01,
    BOUNDS_M:            [0, 0, 8, 6],
    COLLIDE_CIRCLES:     true,
    CONTACT_COMPLIANCE_M_PER_N: 0
   },
   RENDER: {
    BG:                  '#0b0d12',
    LINK_STROKE:         '#d43375',
    LINK_WIDTH_PX:       3,
    PARTICLE_FILL:       '#ffd166',
    PARTICLE_STROKE:     '#222',
    PARTICLE_STROKE_W:   1,
    PIN_FILL:            '#ff6b6b',
    SHOW_BOUNDS:         false,
    PIXELS_PER_METER:    130
   },
   DEMO: {
    ROPE_COUNT:          200,
    ROPE_START_M:        {x: 4, y: 0.8},
    ROPE_SEG_LEN_M:      0.10,
    ROPE_NODE_MASS_KG:   0.01,
    ROPE_NODE_RADIUS_M:  0.025,
    ROPE_STIFFNESS_N_PER_M: 1e8,

    BALL_POS_M:          {x: 6, y: 4.3},
    BALL_RADIUS_M:       0.30,
    BALL_MASS_KG:        2,

    MAX_FRAME_DT_S:      1/30,
    CLICK_POKE_N_PER_M:  300
   }
  };

  // =========================
  // XPBD core
  // =========================
  const INTERNAL = { EPS_M: 1e-9, LAMBDA_DECAY: 1.0 };
  function XPBD(opt = {}) {
   const Wd = {
    dt: opt.dt ?? TUNE.SIM.DT_S,
    substeps: opt.substeps ?? TUNE.SIM.SUBSTEPS,
    iters: opt.iters ?? TUNE.SIM.ITERS,
    g: opt.g ?? TUNE.SIM.GRAVITY_MPS2.slice(),
    drag: opt.drag ?? TUNE.SIM.DRAG,
    bounds: opt.bounds ?? (TUNE.SIM.BOUNDS_M && TUNE.SIM.BOUNDS_M.slice()),
    contactCompliance: opt.contactCompliance ?? TUNE.SIM.CONTACT_COMPLIANCE_M_PER_N,
    collide: opt.collide ?? TUNE.SIM.COLLIDE_CIRCLES,
    P: [],  // particles
    C: [],  // distance constraints
    T: []   // tethers (unused here but supported)
   };
   function add(x_m, y_m, mass_kg = 1, radius_m = 0, col_mask=7) {
    const w = mass_kg > 0 ? 1 / mass_kg : 0;
    const p = { x: x_m, y: y_m, px: x_m, py: y_m, vx: 0, vy: 0, w, r: radius_m, col_mask };
    Wd.P.push(p); return p;
   }
   function setStatic(p, yes = true) { p.w = yes ? 0 : (p.w || 1); }
   function link(a, b, rest_m = null, compliance_m_per_N = 0) {
    if (rest_m == null) { const dx = b.x - a.x, dy = b.y - a.y; rest_m = Math.hypot(dx, dy); }
    const c = { a, b, rest: rest_m, comp: compliance_m_per_N, lam: 0 };
    Wd.C.push(c); return c;
   }
   function addForce(p, Fx_N, Fy_N) {
    if (!p.w) return p;
    p.vx += (Fx_N * p.w) * Wd.dt;
    p.vy += (Fy_N * p.w) * Wd.dt;
    return p;
   }
   function step(dt = Wd.dt) {
    const P = Wd.P, Cn = Wd.C, Th = Wd.T, g = Wd.g, drag = Wd.drag, sub = Wd.substeps, it = Wd.iters;
    const hasBounds = !!Wd.bounds, B = Wd.bounds;
    const doCollide = !!Wd.collide, cComp = Wd.contactCompliance;

    const sdt = dt / sub;
    const invDrag = 1 / (1 + drag);
    const alphaScale = sdt * sdt;

    for (let s = 0; s < sub; s++) {
     // integrate
     for (let i = 0; i < P.length; i++) {
      const p = P[i];
      p.px = p.x; p.py = p.y;
      if (!p.w) continue;
      p.vx += g[0] * sdt; p.vy += g[1] * sdt;
      p.vx *= invDrag;    p.vy *= invDrag;
      p.x += p.vx * sdt;  p.y += p.vy * sdt;
     }

     // solver iterations
     for (let k = 0; k < it; k++) {
      // Teathers constraints (equality)
      for (let i = 0; i < Th.length; i++) {
       const t = Th[i], a = t.a, b = t.b;
       let dx = a.x - b.x, dy = a.y - b.y;
       let d = Math.hypot(dx, dy); if (d < INTERNAL.EPS_M) d = INTERNAL.EPS_M;
       const Cval = t.max - d;
       if (Cval >= 0) { t.lam = 0; continue; }
       const nx = dx / d, ny = dy / d;
       const wsum = a.w + b.w; if (wsum === 0) continue;
       const alpha = (t.comp || 0) / alphaScale;
       const oldLam = Math.max(0, t.lam) * INTERNAL.LAMBDA_DECAY;
       let dlam = (-Cval - alpha * oldLam) / (wsum + alpha);
       let newLam = oldLam + dlam;
       if (newLam < 0) { dlam = -oldLam; newLam = 0; }
       const px = dlam * nx, py = dlam * ny;
       if (a.w) { a.x -= px * a.w; a.y -= py * a.w; }
       if (b.w) { b.x += px * b.w; b.y += py * b.w; }
       t.lam = newLam;
      }

      // Distance constraints (equality)
      for (let i = 0; i < Cn.length; i++) {
       const c = Cn[i], a = c.a, b = c.b;
       let dx = b.x - a.x, dy = b.y - a.y;
       let d = Math.hypot(dx, dy);
       if (d < INTERNAL.EPS_M) continue;
       const nx = dx / d, ny = dy / d;
       const Cval = d - c.rest;
       const wsum = a.w + b.w;
       if (wsum === 0) { c.lam = 0; continue; }
       const alpha = (c.comp || 0) / alphaScale;
       const oldLam = c.lam * INTERNAL.LAMBDA_DECAY;
       const dlam = (-Cval - alpha * oldLam) / (wsum + alpha);
       c.lam = oldLam + dlam;
       const px = dlam * nx, py = dlam * ny;
       if (a.w) { a.x -= px * a.w; a.y -= py * a.w; }
       if (b.w) { b.x += px * b.w; b.y += py * b.w; }
      }

      // bounds
      if (hasBounds) {
       const [minx, miny, maxx, maxy] = B;
       for (let i = 0; i < P.length; i++) {
        const p = P[i], r = p.r || 0;
        if (p.x < minx + r) p.x = minx + r;
        if (p.x > maxx - r) p.x = maxx - r;
        if (p.y < miny + r) p.y = miny + r;
        if (p.y > maxy - r) p.y = maxy - r;
       }
      }

      // circleâ€“circle contacts
      if (doCollide) {
       const alphaC = (cComp || 0) / alphaScale;
       for (let i = 0; i < P.length; i++) {
        const a = P[i]; if (!a.r) continue;
        for (let j = i + 1; j < P.length; j++) {
         const b = P[j]; if (!b.r) continue;
         if ((a.col_mask & b.col_mask) === 0) continue;
         let dx = b.x - a.x, dy = b.y - a.y;
         let d = Math.hypot(dx, dy); if (d < INTERNAL.EPS_M) d = INTERNAL.EPS_M;
         const rs = (a.r || 0) + (b.r || 0);
         const Cval = d - rs; if (Cval >= 0) continue;
         const nx = dx / d, ny = dy / d;
         const wsum = a.w + b.w; if (wsum === 0) continue;
         const dlam = (-Cval) / (wsum + alphaC);
         const px = dlam * nx, py = dlam * ny;
         if (a.w) { a.x -= px * a.w; a.y -= py * a.w; }
         if (b.w) { b.x += px * b.w; b.y += py * b.w; }
        }
       }
      }
     }

     // velocity update
     for (let i = 0; i < P.length; i++) {
      const p = P[i];
      p.vx = (p.x - p.px) / sdt;
      p.vy = (p.y - p.py) / sdt;
     }
    }
   }
   function stiffnessToCompliance(k_N_per_m) { return k_N_per_m > 0 ? 1 / k_N_per_m : 0; }
   return {
    P: Wd.P, C: Wd.C, T: Wd.T,
    get dt() { return Wd.dt; }, set dt(v) { Wd.dt = v; },
    get iters() { return Wd.iters; }, set iters(v) { Wd.iters = v | 0; },
    get substeps() { return Wd.substeps; }, set substeps(v) { Wd.substeps = v | 0; },
    get gravity() { return Wd.g; }, set gravity(g) { Wd.g = g; },
    get bounds() { return Wd.bounds; }, set bounds(b) { Wd.bounds = b; },
    get collide() { return Wd.collide; }, set collide(v) { Wd.collide = !!v; },
    add, setStatic, link, addForce, step, stiffnessToCompliance
   };
  }

  // =====================
  // Simulator (ALL physics)
  // =====================
  function makeSimulator() {
   const sim = XPBD({
    dt: TUNE.SIM.DT_S,
    iters: TUNE.SIM.ITERS,
    substeps: TUNE.SIM.SUBSTEPS,
    g: TUNE.SIM.GRAVITY_MPS2,
    bounds: TUNE.SIM.BOUNDS_M,
    collide: TUNE.SIM.COLLIDE_CIRCLES,
    contactCompliance: TUNE.SIM.CONTACT_COMPLIANCE_M_PER_N
   });

   // scene statics (physics coords in meters; renderer reads as-is)
   const [BX0, BY0, BX1, BY1] = TUNE.SIM.BOUNDS_M;
   const BW = BX1 - BX0, BH = BY1 - BY0;
   const platform = { r: 0.12, x1: BX0 + BW * 0.10, y1: BY0 + BH * 0.70, x2: BX0 + BW * 0.70, y2: BY0 + BH * 0.60 };
   const peg = { r: 0.20, x: BX0 + BW * 0.80, y: BY0 + BH * 0.40 };

   // rope + ball
   const N = TUNE.DEMO.ROPE_COUNT;
   const start = TUNE.DEMO.ROPE_START_M;
   const segLen = TUNE.DEMO.ROPE_SEG_LEN_M;
   const rope = [];
   let prev = sim.add(start.x, start.y, 0, TUNE.DEMO.ROPE_NODE_RADIUS_M, 6); // pinned static
   rope.push(prev);
   for (let i = 1; i < N; i++) {
    const p = sim.add(start.x + i * segLen, start.y, TUNE.DEMO.ROPE_NODE_MASS_KG, TUNE.DEMO.ROPE_NODE_RADIUS_M, 6);
    sim.link(prev, p, segLen, sim.stiffnessToCompliance(TUNE.DEMO.ROPE_STIFFNESS_N_PER_M));
    rope.push(p);
    prev = p;
   }
   const ball = sim.add(TUNE.DEMO.BALL_POS_M.x, TUNE.DEMO.BALL_POS_M.y, TUNE.DEMO.BALL_MASS_KG, TUNE.DEMO.BALL_RADIUS_M, 8);

   // wound path (local to ball)
   function buildWoundPath(total, segLen_m, R_m) {
    const wX = new Array(total).fill(0), wY = new Array(total).fill(0);
    const inner = Math.max(0.001, R_m - 0.06), outer = R_m;
    const locals = [];
    const pushFar = p => {
     if (!locals.length) { locals.push(p); return; }
     const q = locals[locals.length - 1], d = hypot(p.x - q.x, p.y - q.y);
     if (d < segLen_m) {
      const nx = (p.x - q.x) / (d || 1), ny = (p.y - q.y) / (d || 1);
      locals.push({ x: q.x + nx * segLen_m, y: q.y + ny * segLen_m });
     } else locals.push(p);
    };
    pushFar({ x: inner, y: inner });
    const layers = [
     { tilt: -0.35, count: 2, wR: 0.06 * inner, wT: 0.20 },
     { tilt:  0.55, count: 2, wR: 0.05 * inner, wT: 0.18 },
     { tilt:  1.10, count: 2, wR: 0.05 * inner, wT: 0.15 }
    ];
    for (const L of layers) {
     for (let k = 0; k < L.count; k++) {
      const phase = (k + .5) / L.count * PI * .7, ct = cos(L.tilt + phase), st = sin(L.tilt + phase);
      for (let a = -PI * .98; a <= PI * .98; a += PI) {
       const ca = cos(a), sa = sin(a);
       let x = inner * (ca * ct - sa * st), y = inner * (ca * st + sa * ct);
       const t = (a + PI) / (2 * PI), inward = .25 + .75 * sin(t * PI), r = inner + 2 * L.wR * inward;
       const len = hypot(x, y) || 1; x *= r / len; y *= r / len;
       const jitter = (sin((a + phase) * 23.71) * .5 + .5) * L.wT, ang = atan2(y, x) + jitter * .15;
       pushFar({ x: r * cos(ang), y: r * sin(ang) });
      }
     }
    }
    while (locals.length < total) {
     const a = random() * PI * 2, rr = outer + (inner - outer) * random();
     pushFar({ x: rr * cos(a), y: rr * sin(a) });
    }
    for (let i = 0; i < total; i++) { const p = locals[i] || locals[locals.length - 1]; wX[i] = p.x; wY[i] = p.y; }
    return { wX, wY };
   }
   const woundLocal = buildWoundPath(N, segLen, TUNE.DEMO.BALL_RADIUS_M);
   let freeCount = 0;

   function worldAnchor(i, cx, cy, ang = 0) {
    const ca = cos(ang), sa = sin(ang);
    const wx = cx + (woundLocal.wX[i] * ca - woundLocal.wY[i] * sa);
    const wy = cy + (woundLocal.wX[i] * sa + woundLocal.wY[i] * ca);
    return { x: wx, y: wy };
   }

   // initialize: place rope onto wound path, make all static
   (function layoutInitial() {
    for (let i = 0; i < N; i++) {
     const a = worldAnchor(i, ball.x, ball.y, 0);
     const p = rope[i];
     p.x = p.px = a.x; p.y = p.py = a.y; p.vx = p.vy = 0;
     p.w = 0; // static while on spool
    }
    rope[0].w = 0;
    freeCount = 0;
   })();

   function freeSegments(n = 1) {
    for (let k = 0; k < n && freeCount < N; k++) {
     const idx = freeCount;
     const p = rope[idx];
     p.w = 1 / TUNE.DEMO.ROPE_NODE_MASS_KG;          // make dynamic
     p.vx = ball.vx; p.vy = ball.vy;                 // inherit ball velocity
     freeCount++;
    }
    // keep the next node pinned (static) to the wound path
    if (freeCount < N) {
     rope[freeCount].w = 0;
    }
   }

   // Physics advance: updates kinematic pins (wound nodes) and steps world
   function advance(dt) {
    // Update positions of all still-wound nodes including the "pin" node.
    if (freeCount < N) {
     const pin = rope[freeCount];
     const a0 = worldAnchor(freeCount, ball.x, ball.y, 0);
     pin.x = a0.x; pin.y = a0.y; pin.px = a0.x; pin.py = a0.y; // kinematic target
    }
    for (let i = freeCount + 1; i < N; i++) {
     const p = rope[i];
     const a = worldAnchor(i, ball.x, ball.y, 0);
     p.x = a.x; p.y = a.y; p.px = a.x; p.py = a.y; p.vx = 0; p.vy = 0; p.w = 0; // fully static wound
    }
    sim.step(dt);
   }

   function applyPoke(wx, wy, k = TUNE.DEMO.CLICK_POKE_N_PER_M) {
    sim.addForce(ball, (wx - ball.x) * k, (wy - ball.y) * k);
   }

   // Renderer-facing snapshot (read-only views)
   function getRenderData() {
    // Tail nodes are indices [0, freeCount]; wound polyline is the local wound beyond freeCount.
    const tailCount = Math.min(freeCount, N);
    const tail = [];
    for (let i = 0; i < tailCount; i++) tail.push({ x: rope[i].x, y: rope[i].y });
    // Build the world-space polyline of the remaining wound section for pretty drawing
    const wound = [];
    if (freeCount < N - 1) {
     for (let i = freeCount; i < N; i++) {
      const a = worldAnchor(i, ball.x, ball.y, 0);
      wound.push(a);
     }
    }
    // basic HUD numbers
    const freedLength_m = TUNE.DEMO.ROPE_SEG_LEN_M * freeCount;
    return {
     bounds: TUNE.SIM.BOUNDS_M.slice(),
     tail, wound,
     ball: { x: ball.x, y: ball.y, r: ball.r },
     platform, peg,
     hud: { freedLength_m },
    };
   }

   return {
    advance, freeSegments, applyPoke, getRenderData
   };
  }

  // ==================================
  // Renderer (ALL graphics)
  // ==================================
  function makeRenderer() {
   const cfg = {
    pixelsPerMeter: TUNE.RENDER.PIXELS_PER_METER,
    bg: TUNE.RENDER.BG,
    linkStroke: TUNE.RENDER.LINK_STROKE,
    linkWidth: TUNE.RENDER.LINK_WIDTH_PX,
    showBounds: TUNE.RENDER.SHOW_BOUNDS
   };
   const S = cfg.pixelsPerMeter;

   function clear() {
    X.fillStyle = cfg.bg;
    X.fillRect(0, 0, C.clientWidth, C.clientHeight);
   }
   function toPx(bounds, x, y) {
    const [BX0, BY0] = bounds;
    return [(x - BX0) * S, (y - BY0) * S];
   }
   function toLen(lm) { return lm * S; }

   function drawBounds(bounds) {
    if (!cfg.showBounds) return;
    const [minx, miny, maxx, maxy] = bounds;
    X.strokeStyle = 'rgba(255,255,255,.2)';
    X.lineWidth = 1;
    X.strokeRect((minx-minx)*S, (miny-miny)*S, (maxx-minx)*S, (maxy-miny)*S);
   }

   function drawStaticsAndHUD(state) {
    const {bounds, platform, peg, ball, hud} = state;
    const [BX0, _, BX1, BY1] = bounds;

    // floor
    X.strokeStyle = '#444'; X.lineWidth = 0.05 * S;
    X.beginPath();
    let p0 = toPx(bounds, BX0, BY1); let p1 = toPx(bounds, BX1, BY1);
    X.moveTo(p0[0], p0[1]); X.lineTo(p1[0], p1[1]); X.stroke();

    // platform
    X.strokeStyle = '#666'; X.lineCap = 'round'; X.lineWidth = platform.r * S;
    p0 = toPx(bounds, platform.x1, platform.y1); p1 = toPx(bounds, platform.x2, platform.y2);
    X.beginPath(); X.moveTo(p0[0], p0[1]); X.lineTo(p1[0], p1[1]); X.stroke();

    // peg
    const pegPx = toPx(bounds, peg.x, peg.y);
    X.fillStyle = '#666';
    X.beginPath(); X.arc(pegPx[0], pegPx[1], toLen(peg.r), 0, Math.PI * 2); X.fill();

    // HUD
    X.fillStyle = '#fff'; X.font = '14px system-ui,sans-serif';
    X.fillText('yarn: ' + hud.freedLength_m.toFixed(1) + ' m', 12, 22);
   }

   function drawYarn(state) {
    const {bounds, tail, wound} = state;
    const mp = (a, b) => 0.5 * (a + b);
    const n = tail.length + wound.length;
    if (n < 2) return;

    // midpoints
    const m = new Array(2 * n - 1);
    for (let i = 0; i < m.length; i = i + 2) {
     let curArr, currIdx, nextArr, nextIdx;
     let idx = (i / 2) | 0;
     if (idx < tail.length - 1) { curArr = tail; currIdx = idx; nextArr = tail; nextIdx = idx + 1; }
     else if (idx === tail.length - 1) { curArr = tail; currIdx = idx; nextArr = wound; nextIdx = 0; }
     else { curArr = wound; currIdx = idx - tail.length; nextArr = wound; nextIdx = currIdx + 1; }
     m[i] = { x: curArr[currIdx].x, y: curArr[currIdx].y };
     if (nextIdx >= nextArr.length) break;
     m[i + 1] = { x: mp(curArr[currIdx].x, nextArr[nextIdx].x), y: mp(curArr[currIdx].y, nextArr[nextIdx].y) };
    }
    X.lineCap = 'round'; X.lineJoin = 'round'; X.strokeStyle = cfg.linkStroke; X.lineWidth = cfg.linkWidth;
    X.beginPath();
    const start = toPx(bounds, m[0].x, m[0].y);
    X.moveTo(start[0], start[1]);
    for (let i = 1; i < m.length - 1; i = i + 2) {
     const ctrl = toPx(bounds, m[i].x, m[i].y);
     const knot = toPx(bounds, m[i + 1].x, m[i + 1].y);
     X.quadraticCurveTo(ctrl[0], ctrl[1], knot[0], knot[1]);
    }
    X.stroke();
   }

   function draw(state) {
    clear();
    drawBounds(state.bounds);
    drawYarn(state);
    drawStaticsAndHUD(state);
   }

   function screenToMeters(bounds, clientX, clientY) {
    const rect = C.getBoundingClientRect();
    const lx = (clientX - rect.left) / DPR;
    const ly = (clientY - rect.top) / DPR;
    const [BX0, BY0] = bounds;
    return { x: BX0 + lx / S, y: BY0 + ly / S };
   }

   return { draw, screenToMeters };
  }

  // =====================
  // Wire-up: sim + renderer
  // =====================
  const simCtl = makeSimulator();
  const renderer = makeRenderer();

  // =====================
  // Animate (pure orchestration)
  // =====================
  fitCanvasToWindow();
  let last = performance.now();
  function tick(t) {
   const dt = clamp((t - last) / 1000, 0, TUNE.DEMO.MAX_FRAME_DT_S);
   last = t;

   // physics
   simCtl.advance(dt);

   // render
   const state = simCtl.getRenderData();
   renderer.draw(state);

   requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  // =====================
  // Input: click applies a force + frees segments
  // =====================
  C.addEventListener('click', e => {
   const state = simCtl.getRenderData();
   const wp = renderer.screenToMeters(state.bounds, e.clientX, e.clientY);
   simCtl.applyPoke(wp.x, wp.y, TUNE.DEMO.CLICK_POKE_N_PER_M);
   simCtl.freeSegments(10);
  });
 });
</script>
